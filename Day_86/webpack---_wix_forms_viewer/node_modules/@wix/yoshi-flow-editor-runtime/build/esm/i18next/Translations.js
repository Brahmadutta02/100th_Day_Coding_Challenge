var __awaiter = (this && this.__awaiter) || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new(P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }

        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }

        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function(thisArg, body) {
    var _ = {
            label: 0,
            sent: function() {
                if (t[0] & 1) throw t[1];
                return t[1];
            },
            trys: [],
            ops: []
        },
        f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;

    function verb(n) {
        return function(v) {
            return step([n, v]);
        };
    }

    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [6, e];
            y = 0;
        } finally {
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var defaultTranslationsFunction = function() {
    throw new Error('Translations has not been initialized yet');
};
export var disabledTranslationsFunction = function() {
    throw new Error('You are using t function, but have disabled translations.');
};
export var DEFAULT_LANGUAGE = 'en';
var Translations = /** @class */ (function() {
    function Translations(_a) {
        var _this = this;
        var language = _a.language,
            defaultTranslations = _a.defaultTranslations,
            _b = _a.prefix,
            prefix = _b === void 0 ? 'messages' : _b,
            defaultLanguage = _a.defaultLanguage,
            availableLanguages = _a.availableLanguages,
            localeDistPath = _a.localeDistPath,
            initI18n = _a.initI18n,
            basePath = _a.basePath;
        this.t = defaultTranslationsFunction;
        this.all = {};
        this.init = function(_a) {
            var _b = _a === void 0 ? {} : _a,
                prepopulated = _b.prepopulated,
                _c = _b.wait,
                wait = _c === void 0 ? false : _c,
                _d = _b.useSuspense,
                useSuspense = _d === void 0 ? false : _d;
            return __awaiter(_this, void 0, void 0, function() {
                var config, availableLanguages, translationDataForLanguage;
                var _this = this;
                return __generator(this, function(_e) {
                    switch (_e.label) {
                        case 0:
                            config = this.config;
                            availableLanguages = new Set(config.availableLanguages || []);
                            if (!this._initI18n) {
                                throw new Error("Can't initialize i18n without initI18n method.");
                            }
                            this.i18n = this._initI18n({
                                locale: config.language,
                                useSuspense: useSuspense,
                                wait: wait,
                                messages: prepopulated,
                                disableAutoInit: true,
                                asyncMessagesLoader: function(locale) {
                                    var _a;
                                    if (locale === DEFAULT_LANGUAGE) {
                                        return Promise.resolve(config.defaultTranslations);
                                    }
                                    if (!availableLanguages.has(locale)) {
                                        return Promise.reject(new Error("Locale assets for " + locale + " are not provided"));
                                    }
                                    // locales are fetched and not imported because
                                    // `bolt` SSR environment doesn't support webpack's `JsonpTemplatePlugin`
                                    // see also:
                                    //   https://github.com/wix-private/site-search/pull/369
                                    //   https://github.com/wix-private/site-search/commit/93a16dfbe1fcca9af7cc1abe88f0e0df222970c8
                                    return fetch("" + ((_a = _this.basePath) !== null && _a !== void 0 ? _a : __webpack_public_path__) + _this.localeDistPath + "/" + config.prefix + "_" + locale + ".json").then(function(r) {
                                        if (!r.ok) {
                                            return Promise.reject(new Error("Can't load locale: " + config.language));
                                        }
                                        return r.json();
                                    });
                                },
                            });
                            return [4 /*yield*/ , this.i18n.init()];
                        case 1:
                            _e.sent();
                            translationDataForLanguage = this.i18n.getResourceBundle(config.language, 'translation');
                            if (!translationDataForLanguage &&
                                availableLanguages.has(config.language)) {
                                // The i18n data store should have being populated by now since `await this.i18n.init()` above
                                // Ideally we should catch this error in the client side and show an appropriate message and report it to Sentry
                                throw new Error("Unexpected missing translations for language " + config.language);
                            }
                            this.all = translationDataForLanguage || config.defaultTranslations || {};
                            this.t = function(key, options) {
                                return _this.i18n.t(key, options);
                            };
                            return [2 /*return*/ , this];
                    }
                });
            });
        };
        this.config = {
            availableLanguages: availableLanguages,
            language: language,
            defaultTranslations: defaultTranslations,
            prefix: prefix,
            defaultLanguage: defaultLanguage,
        };
        this.localeDistPath = localeDistPath;
        this._initI18n = initI18n;
        this.i18n = null;
        this.basePath = basePath;
    }
    return Translations;
}());
export {
    Translations
};
//# sourceMappingURL=Translations.js.map