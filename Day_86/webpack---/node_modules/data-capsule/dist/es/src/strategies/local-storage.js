import {
    __awaiter,
    __extends,
    __generator
} from "tslib";
import {
    BaseStorage
} from '../base-storage';
import {
    verifyConsentPolicy,
} from '../consent-policy';
import {
    KEY_SEPARATOR,
    LOCAL_STORAGE_UNSUPPORTED,
    NOT_FOUND,
    PREFIX_SEPARATOR,
    STORAGE_PREFIX,
} from '../utils/constants';
import {
    localStorageCleaner
} from '../utils/local-storage-cleaner';
import {
    deserializeData,
    getCacheRecords,
    isExpired,
} from '../utils/record-utils';
var LocalStorageStrategy = /** @class */ (function(_super) {
    __extends(LocalStorageStrategy, _super);

    function LocalStorageStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LocalStorageStrategy.prototype.setItem = function(key, value, options) {
        return __awaiter(this, void 0, void 0, function() {
            var serializedKey, serializedValue;
            return __generator(this, function(_a) {
                serializedKey = getCacheKey(key, options);
                serializedValue = serializeData(value, options);
                // not mandatory, yet (gradual enforcement)
                if (options.category) {
                    verifyConsentPolicy(options.category);
                }
                try {
                    localStorage.setItem(serializedKey, serializedValue);
                } catch (e) {
                    localStorageCleaner(serializedKey.length + serializedValue.length);
                    localStorage.setItem(serializedKey, serializedValue);
                }
                return [2 /*return*/ ];
            });
        });
    };
    LocalStorageStrategy.prototype.getItem = function(key, options) {
        var fullKey = getCacheKey(key, options);
        var data;
        try {
            data = localStorage.getItem(fullKey);
        } catch (e) {
            return Promise.reject(LOCAL_STORAGE_UNSUPPORTED);
        }
        data = data && deserializeData(data);
        if (data && !isExpired(data)) {
            updateAccessTime(fullKey, data);
            return Promise.resolve(data.value);
        } else {
            return Promise.reject(NOT_FOUND);
        }
    };
    LocalStorageStrategy.prototype.removeItem = function(key, options) {
        key = getCacheKey(key, options);
        localStorage.removeItem(key);
        return Promise.resolve();
    };
    LocalStorageStrategy.prototype.getAllItems = function(options) {
        var prefix = getCachePrefix(options);
        var items = {};
        getCacheRecords(prefix).forEach(function(record) {
            if (!isExpired(record)) {
                items[record.key] = record.value;
            }
        });
        return Promise.resolve(items);
    };
    return LocalStorageStrategy;
}(BaseStorage));
export {
    LocalStorageStrategy
};

function getCacheKey(key, options) {
    return getCachePrefix(options) + key;
}

function stringify(obj) {
    return typeof obj === 'string' ? obj : JSON.stringify(obj);
}

function getCachePrefix(options) {
    return ([STORAGE_PREFIX, options.namespace, stringify(options.scope)]
        .filter(function(x) {
            return x;
        })
        .join(PREFIX_SEPARATOR) + KEY_SEPARATOR);
}

function serializeData(value, options) {
    var data = {
        lastUsed: Date.now(),
        createdAt: options.createdAt || Date.now(),
        expiration: options.expiration,
        value: value,
    };
    return JSON.stringify(data);
}

function updateAccessTime(fullKey, data) {
    var expiration = data.expiration,
        createdAt = data.createdAt;
    localStorage.setItem(fullKey, serializeData(data.value, {
        expiration: expiration,
        createdAt: createdAt
    }));
}
//# sourceMappingURL=local-storage.js.map