import {
    gradientConstants
} from './constants.js';
const {
    GRADIENT_LINEAR,
    GRADIENT_CONIC,
    GRADIENT_CIRCLE,
} = gradientConstants.TYPES;
const {
    RADIAL_GRADIENT,
    CONIC_GRADIENT,
    LINEAR_GRADIENT,
} = gradientConstants.CSS_FUNC;
const {
    REPEATING,
    DEG,
    AT_CENTER,
    CIRCLE,
    ELLIPSE,
    FROM,
    PERCENTAGE,
} = gradientConstants;
/**
 *
 * @param {GradientData | GradientData[] | GradientMesh} gradients List of Objects representing gradient's data.
 * @param {Object?} options
 * @param {number?} options.alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param {function?} options.resolveColor an optional color parsing function for unsupported formats conversion
 * @return {string} CSS string of gradients
 */
function generate(gradients = [], options = {}) {
    if (!Array.isArray(gradients)) {
        gradients = Array.isArray(gradients.gradients) ?
            gradients.gradients :
            [gradients];
    }
    return gradients
        .map((gradient) => generateGradientFromDatum(gradient, options))
        .join(', ');
}
/**
 * Validate if a gradient is valid, currently doing a loose comparison. Will harden the validation if needed
 * @param {any | GradientData | GradientData[] | GradientMesh} gradients List of Objects representing gradient's data.
 * @returns {boolean} Whether the gradients are valid
 */
function validate(gradients = []) {
    if (!gradients) {
        gradients = [];
    } else if (!Array.isArray(gradients)) {
        gradients = Array.isArray(gradients.gradients) ?
            gradients.gradients :
            [gradients];
    }
    const types = Object.values(gradientConstants.TYPES);
    return (gradients.length &&
        gradients.every((gradient) => gradient &&
            types.includes(gradient.type) &&
            gradient.colorStops &&
            gradient.colorStops.length));
}
/**
 * Convert hex color (with or withour alpha) and a passed alpha value to an rgba string
 * NOTE: Does not validate the input
 * @param {string} hex color in the format of #FFF #FFFFFF or #FFFFFFFF
 * @param {number?} alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @returns {string} rgba(255,255,255,100)
 */
function hex2rgba(hex, alpha = 1) {
    const shortHex = hex.length === 4;
    const matcher = shortHex ? /\w/g : /\w\w/g;
    const [r, g, b, a = 255] = hex
        .match(matcher)
        .map((x) => parseInt(x.repeat(shortHex ? 2 : 1), 16));
    return `rgba(${r},${g},${b},${(a / 255) * alpha})`;
}
/**
 *
 * @param {string} wixRgba r,g,b,a
 * @returns {[string, number]} touple of hex color and alpha
 */
export function wrgba2hex_a(wixRgba) {
    const [r, g, b, a] = wixRgba.split(/,\s*/);
    return [
        `#${((1 << 24) + (+r << 16) + (+g << 8) + +b)
            .toString(16)
            .slice(1)
            .toUpperCase()}`, +a,
    ];
}
/**
 * check if value is wix data r,g,b,a format
 * @param {string} color
 * @returns {boolean}
 */
function isWixRgba(color) {
    return /^(\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)$/.test(color);
}

function isHex(color) {
    return /^#(?:[0-9a-fA-F]{3}){1,2}$/i.test(color);
}
/**
 *
 * @param {GradientData} gradient
 * @param {Object?} options
 * @param {number?} options.alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param {function?} options.resolveColor an optional color parsing function for unsupported formats conversion
 * @return {string}
 */
function generateGradientFromDatum(gradient, options) {
    const gradientRepeat = gradient.repeat ? `${REPEATING}-` : '';
    const gradientString = generateGradientByType(gradient);
    const gradientColorStops = generateColorStops(gradient.colorStops, options);
    return `${gradientRepeat}${gradientString}${gradientColorStops})`;
}
/**
 *
 * @param {GradientData} gradient
 * @return {string} gradient type CSS string
 */
function generateGradientByType(gradient) {
    if (gradient.type === GRADIENT_LINEAR) {
        return generateLinear(gradient);
    }
    if (gradient.type === GRADIENT_CONIC) {
        return generateConic(gradient);
    }
    return generateRadial(gradient);
}
/**
 *
 * @param {GradientData} gradient
 * @return {string} linear-gradient string
 */
function generateLinear({
    angle = 0
}) {
    const gradientAngle = generateGradientAngle(angle, ', ');
    return `${LINEAR_GRADIENT}(${gradientAngle}`;
}
/**
 *
 * @param {GradientData} gradient
 * @return {string} radial-gradient string
 */
function generateRadial({
    size,
    position,
    type
}) {
    const gradientSize = generateGradientSize(size);
    const gradientPosition = generateGradientPosition(position, type);
    const radialShape = type === GRADIENT_CIRCLE ? CIRCLE : ELLIPSE;
    return `${RADIAL_GRADIENT}(${radialShape} ${gradientSize}${gradientPosition}`;
}
/**
 *
 * @param {GradientData} gradient
 * @return {string} conic-gradient string
 */
function generateConic({
    angle = 0,
    position,
    type
}) {
    const gradientPosition = generateGradientPosition(position, type);
    const gradientAngle = generateGradientAngle(angle);
    const angleDelimiter = position ? ' ' : ', ';
    return `${CONIC_GRADIENT}(${FROM} ${gradientAngle}${angleDelimiter}${gradientPosition}`;
}
/**
 *
 * @param {UnitLengthPercentage} data
 * @return {string} background values string
 */
function generateUnitSize({
    type,
    value
}) {
    if (type === PERCENTAGE) {
        return `${value}%`;
    }
    return `${value}${type}`;
}
/**
 *
 * @param {number} angle
 * @param {string} [suffix] defaults to `''`.
 * @return {string} gradient angle string
 */
function generateGradientAngle(angle, suffix = '') {
    return `${angle}${DEG}${suffix}`;
}
/**
 *
 * @param {object} [size = {}]
 * @return {string} gradient size string
 */
function generateGradientSize(size) {
    size = size || {};
    if (size.keyword) {
        return `${size.keyword} `;
    }
    if (size.width && size.height) {
        const sizeWidth = generateUnitSize(size.width);
        const sizeHeight = generateUnitSize(size.height);
        return `${sizeWidth} ${sizeHeight} `;
    }
    if (size.value) {
        return `${size.value}${size.type === PERCENTAGE ? '%' : size.type} `;
    }
    return '';
}
/**
 *
 * @param {{x: number, y: number}} position
 * @param {string} type
 * @return {string} gradient position string
 */
function generateGradientPosition(position, type) {
    if (!position) {
        if (type === GRADIENT_CONIC) {
            return '';
        }
        return `${AT_CENTER}, `;
    }
    const xPosition = generateUnitSize(position.x);
    const yPosition = generateUnitSize(position.y);
    return `at ${xPosition} ${yPosition}, `;
}
/**
 *
 * @param {ColorStop[]} colorStops
 * @param {Object?} options
 * @param {number?} options.alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param {function?} options.resolveColor an optional color parsing function for unsupported formats conversion
 * @return {string} gradient colorStops string
 */
function generateColorStops(colorStops = [], options) {
    return colorStops
        .map((colorStop) => generateColorStop(colorStop, options))
        .join(', ');
}
/**
 *
 * @param {string?} color hex color or an 'r,g,b,a' string, a ignored is opacity !== undefined
 * @param {number?} opacity 0...1
 * @param {{type: string, value: number}} size
 * @param {number?} alpha a value between 0 and 1 representing global alpha value to aplly to all gradients
 * @param {function?} resolveColor an optional color parsing function for unsupported formats conversion
 * @return {string} gradient colorStop string
 */
function generateColorStop({
    color,
    opacity,
    size
}, {
    alpha = 1,
    resolveColor
}) {
    let colorStopColor = '';
    let colorStopSize = '';
    if (color) {
        if (resolveColor) {
            color = resolveColor(color);
        }
        if (isHex(color)) {
            opacity !== null && opacity !== void 0 ? opacity : (opacity = 1);
            colorStopColor =
                opacity * alpha < 1 ? hex2rgba(color, opacity * alpha) : color;
        } else if (isWixRgba(color)) {
            const [colorHex, colorAlpha] = wrgba2hex_a(color);
            opacity !== null && opacity !== void 0 ? opacity : (opacity = colorAlpha);
            colorStopColor = hex2rgba(colorHex, opacity * alpha);
        } else {
            colorStopColor = color;
        }
    }
    if (size) {
        const {
            type,
            value
        } = size;
        if (type === PERCENTAGE) {
            colorStopSize = `${value}%`;
        } else {
            colorStopSize = `${value}${type}`;
        }
    }
    if (color && size) {
        return `${colorStopColor} ${colorStopSize}`;
    } else if (color) {
        return colorStopColor;
    }
    return colorStopSize;
}
/**
 * @typedef {Object} GradientMesh
 * @property {'GradientMeshData'} type
 * @property {GradientData[]} gradients
 *
 * @typedef {Object} GradientData
 * @property {'GradientLinear'|'GradientCircle'|'GradientEllipse'|'GradientConic'} type
 * @property {boolean} repeat
 * @property {number} [angle]
 * @property {Object} [position]
 * @property {Object} [size]
 * @property {ColorStop[]} colorStops
 *
 * @typedef {Object} ColorStop
 * @property {string} color
 * @property {UnitLengthPercentage | UnitAnglePercentage} size
 *
 * @typedef {Object} UnitLengthPercentage
 * @property {number} value
 * @property {'px' | 'em' | 'rem' | 'fr' | 'percentage' | 'vh' | 'vw'} type
 *
 * @typedef {Object} UnitAnglePercentage
 * @property {number} value
 * @property {'deg' | 'percentage'} type
 */
export {
    generate,
    validate
};
//# sourceMappingURL=index.js.map