"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateGradient = exports.isValidColor = exports.extractRGBA = exports.getColorFromCssStyle = exports.isHexValue = exports.isRgbValues = exports.isThemeColor = exports.isGreyscale = exports.formatColor = exports.getColorClass = exports.getColorAlpha = exports.getHexColor = exports.getSplitRgbValuesStringWithoutAlpha = exports.getSplitRgbValuesString = exports.getFromColorMap = exports.splitColor = exports.getRGBAColorString = exports.extractThemeColor = exports.brighten = exports.isColor = void 0;
const tslib_1 = require("tslib");
const color_1 = (0, tslib_1.__importDefault)(require("color"));
const css_gradient_generator_1 = require("@wix/css-gradient-generator");
const isColor = (val) => val ? /(^#([a-f\d]{3}){1,2}$)|(^rgba?\(\d+(,\d+){2,3}(\.\d+)?\)$)/i.test(val.replace(/\s/g, '')) : false;
exports.isColor = isColor;
const isRgbValues = (val) => (val ? /^\d+(,\d+){2,3}(\.\d+)?$/.test(val.replace(/\s/g, '')) : false);
exports.isRgbValues = isRgbValues;
const isHexValue = (val) => (val ? /(^#([a-f\d]{3}){1,2}$)/i.test(val.replace(/\s/g, '')) : false);
exports.isHexValue = isHexValue;
const rgbToHexString = (rgb) => `#${rgb
    .map((channel) => {
    const hex = channel.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
})
    .join('')}`;
const getColor = (color) => {
    if ((0, exports.isColor)(color)) {
        return (0, color_1.default)(color);
    }
    if (isRgbValues(color)) {
        return (0, color_1.default)(`rgba(${color})`);
    }
    if (color === 'transparent') {
        return color_1.default.rgb(0, 0, 0, 0);
    }
    return null;
};
const isThemeColor = (color) => /^color_\d+$/.test(color);
exports.isThemeColor = isThemeColor;
const brighten = (colorString, brightnessModifier = 1) => {
    const color = getColor(colorString);
    if (!color) {
        return null;
    }
    const hsvColor = color.hsv();
    return hsvColor
        .value(hsvColor.value() * brightnessModifier)
        .rgb()
        .string();
};
exports.brighten = brighten;
const getRGBAColorString = (color, colorOpacity = 1) => {
    try {
        if (colorOpacity === 'none') {
            return (0, color_1.default)(fixColor(color)).string();
        }
        return (0, color_1.default)(fixColor(color)).alpha(colorOpacity).string();
    } catch (e) {
        return color;
    }
};
exports.getRGBAColorString = getRGBAColorString;
const splitColor = (rgbString) => (0, color_1.default)(rgbString).array().join(',');
exports.splitColor = splitColor;
/**
 * Returns rgb values string from a hex color string input (i.e 255,255,255), null if value given is not a hex color
 * @param value a string value that might be a color
 */
const getSplitRgbValuesString = (value) => {
    const color = getColor(value);
    if (!color) {
        return null;
    }
    return color.rgb().array().join(',');
};
exports.getSplitRgbValuesString = getSplitRgbValuesString;
/**
 * Returns an RGB values from rgb or rgba expressions as a string.
 * If there is an opacity value (alpha) in rgba expression it will be ignored.
 * @param value a string that might be one of the expressions: rgb(r, g, b), or rgba(r, g, b, a)
 */
const getSplitRgbValuesStringWithoutAlpha = (value) => {
    const color = getColor(value);
    if (!color) {
        return null;
    }
    const {
        r,
        g,
        b
    } = color.object();
    return `${r},${g},${b}`;
};
exports.getSplitRgbValuesStringWithoutAlpha = getSplitRgbValuesStringWithoutAlpha;
const getColorAlpha = (value) => {
    const color = getColor(value);
    if (!color) {
        return null;
    }
    return color.alpha();
};
exports.getColorAlpha = getColorAlpha;
/**
 * Given theme color string e.g {color_1} / [color_1] extracts the underlying color - color_1
 * @param str theme color
 */
const extractThemeColor = (str) => {
    return str.replace(new RegExp('[\\[\\]{}]', 'g'), '');
};
exports.extractThemeColor = extractThemeColor;
const getFromColorMap = (rawColor, colorsMap = []) => {
    const [, themeColorIndex] = extractThemeColor(rawColor).split('_');
    const i = parseInt(themeColorIndex, 10);
    return isNaN(i) ? rawColor : colorsMap[i];
};
exports.getFromColorMap = getFromColorMap;
const isGreyscale = (colorObj) => colorObj.red() === colorObj.green() && colorObj.red() === colorObj.blue() && colorObj.red() !== 255;
exports.isGreyscale = isGreyscale;
const getHexColor = (rgbAsString) => {
    const color = getColor(rgbAsString);
    return color && color.hex().toString();
};
exports.getHexColor = getHexColor;
const getColorClass = (className) => {
    const findColorClass = /(color_\d+)/;
    const colorClass = findColorClass.exec(className);
    return colorClass && colorClass[1];
};
exports.getColorClass = getColorClass;
const fixColor = (color) => {
    if ((0, exports.isColor)(color)) {
        return color;
    }
    if (typeof color === 'undefined') {
        return color;
    }
    if ((0, exports.isColor)(`rgba(${color})`)) {
        return `rgba(${color})`;
    }
    if ((0, exports.isColor)(`rgb(${color})`)) {
        return `rgb(${color})`;
    }
    return color.replace(';', '');
};
const formatColor = (value, alpha) => {
    const fixedColor = fixColor(value);
    const color = new color_1.default(fixedColor).alpha(Number(alpha));
    const formattedRgbColor = color.rgb().toString().replace(/ /g, '');
    return Number(alpha) !== 1 ?
        formattedRgbColor :
        formattedRgbColor.replace(/^rgb/, 'rgba').replace(')', `,${color.alpha()})`);
};
exports.formatColor = formatColor;
const getColorFromCssStyle = (value) => {
    const {
        red,
        green,
        blue,
        alpha
    } = value;
    const color = new color_1.default(rgbToHexString([red, green, blue]));
    return formatColor(color.toString(), alpha);
};
exports.getColorFromCssStyle = getColorFromCssStyle;
const extractRGBA = (value) => {
    const rgbaRe = /rgba\([^)]+\)/;
    const result = value.match(rgbaRe);
    if (result && result[0]) {
        return result[0];
    }
    return '';
};
exports.extractRGBA = extractRGBA;
const isValidColor = (color) => (0, exports.isColor)(color) || isRgbValues(color) || isHexValue(color) || isThemeColor(color);
exports.isValidColor = isValidColor;
const generateGradient = (colorLayers, alpha, colorMap) => (0, css_gradient_generator_1.generate)(colorLayers, {
    alpha,
    resolveColor: (color) => getFromColorMap(color, colorMap)
});
exports.generateGradient = generateGradient;
//# sourceMappingURL=color.js.map