"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildSvgUrlFactory = exports.getCSSStrokeAdjustments = exports.getCSSDropShadow = exports.encodeSVG = exports.getSvgContentForMask = exports.getScaledSvgViewBox = exports.getFilter = exports.removeWidthAndHeight = exports.parseSvgString = exports.getShapeDividerImageCss = exports.transformVectorImage = exports.getFontFamilyFontsFromSvg = void 0;
const tslib_1 = require("tslib");
const color_1 = require("../color");
const svgFilters_1 = require("./svgFilters");
Object.defineProperty(exports, "getFilter", {
    enumerable: true,
    get: function() {
        return svgFilters_1.getFilter;
    }
});
const svgParser_1 = require("./svgParser");
Object.defineProperty(exports, "parseSvgString", {
    enumerable: true,
    get: function() {
        return svgParser_1.parseSvgString;
    }
});
const color_2 = (0, tslib_1.__importDefault)(require("color"));
const hoverBoxUtils_1 = require("../hoverBoxUtils");
const viewBoxMatcher = /(viewBox=")([^"]*)(")/i;
const preserveAspectRatioMatcher = /(preserveAspectRatio=")([^"]*)(")/i;
const svgWidthMatcher = /(?:<svg[^>]*)\s(width="[^"]*")/i;
const svgHeightMatcher = /(?:<svg[^>]*)\s(height="[^"]*")/i;
const svgTagMatcher = /(<svg[^>]*)(>)/;
const fillAttributeMatcher = /fill="(.*?)"/gi;
const styleAttributeMatcher = /style="([^"]*)"/i;
const styleTransformMatcher = /transform:([^;]*)/i;
const SVG_TYPES = {
    SHAPE: 'shape',
    TINT: 'tint',
    COLOR: 'color',
    UGC: 'ugc',
};

function setSvgId(svgString, svgId) {
    if (!svgString) {
        return svgString;
    }
    const svgTagMatch = svgString.match(svgTagMatcher);
    if (svgTagMatch) {
        let svgTag = svgTagMatch[0];
        const idMatch = svgTag.match(/id="[-\w]+"/);
        if (idMatch) {
            svgTag = svgTag.replace(idMatch[0], `id="${svgId}"`);
        } else {
            svgTag = svgTag.replace('<svg ', `<svg id="${svgId}" `);
        }
        svgString = svgString.replace(svgTagMatch[0], svgTag);
    }
    return svgString;
}
const symbols = /[\r\n%#()<>?[\\\]^`{|}]/g;
/**
 * Returns a data URI SVG encoded for CSS <url> value
 */
function encodeSVG(svg) {
    const escaped = svg
        .replace(/"/g, "'") // Use single quotes instead of double to avoid encoding.
        .replace(/>\s+</g, '><') // trim
        .replace(/\s{2,}/g, ' ') // trim
        .replace(symbols, encodeURIComponent); // encode symbols
    return `url("data:image/svg+xml,${escaped}")`;
}
exports.encodeSVG = encodeSVG;

function transformToTintColors(svgString, resolvedColor) {
    const baseColor = (0, color_2.default)(resolvedColor);
    return svgString.replace(fillAttributeMatcher, (__, colorToTint) => {
        if (colorToTint === 'none') {
            return 'fill="none"';
        }
        const colorObj = (0, color_2.default)(colorToTint);
        if ((0, color_1.isGreyscale)(colorObj)) {
            const tint = 1 - (255 - colorObj.red()) / 255; // eslint-disable-line no-mixed-operators
            const rTint = Math.floor(baseColor.red() + (255 - baseColor.red()) * tint); // eslint-disable-line no-mixed-operators
            const gTint = Math.floor(baseColor.green() + (255 - baseColor.green()) * tint); // eslint-disable-line no-mixed-operators
            const bTint = Math.floor(baseColor.blue() + (255 - baseColor.blue()) * tint); // eslint-disable-line no-mixed-operators
            const tintedColor = (0, color_2.default)({
                r: rTint,
                g: gTint,
                b: bTint
            });
            // return tinted color
            return `fill="${tintedColor.hex().toString()}"`;
        }
        // no change, return original svg color
        return `fill="${colorToTint}"`;
    });
}

function removeWidthAndHeight(svgString, addIfMissing) {
    if (svgString) {
        const widthMatch = svgString.match(svgWidthMatcher);
        const heightMatch = svgString.match(svgHeightMatcher);
        if (widthMatch && widthMatch.length > 1) {
            svgString = svgString.replace(widthMatch[1], 'width="100%"');
        }
        if (heightMatch && heightMatch.length > 1) {
            svgString = svgString.replace(heightMatch[1], 'height="100%"');
        }
        if (addIfMissing && !(widthMatch && heightMatch)) {
            const dimensions = addIfMissing;
            const newWidth = dimensions.width ? ` width="${dimensions.width}"` : ' width="100%"';
            const newHeight = dimensions.height ? ` height="${dimensions.height}"` : ' height="100%"';
            svgString = svgString.replace(svgTagMatcher, `$1${!widthMatch ? newWidth : ''}${!heightMatch ? newHeight : ''}$2`);
        }
    }
    return svgString;
}
exports.removeWidthAndHeight = removeWidthAndHeight;

function getNoAltA11yAttributes(asString = false) {
    const feats = {
        role: 'presentation',
        'aria-hidden': 'true'
    };
    return asString ?
        Object.entries(feats)
        .map(([key, value]) => `${key}=${value}`)
        .join(' ') :
        feats;
}

function escapeHtml(str) {
    return str.replace(/&/g, '&amp;').replace(/>/g, '&gt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
}

function addA11yAttributes(svgString, compId, altText) {
    const a11yFeatures = altText ? `role="img"` : getNoAltA11yAttributes(true);
    const newSvgString = svgString.replace(svgTagMatcher, `$1 ${a11yFeatures}$2`);
    if (typeof altText === 'string') {
        const svgLabelId = `${compId}-svgtitle`;
        return newSvgString.replace(svgTagMatcher, `$1 aria-labelledby="${svgLabelId}"$2<title id="${svgLabelId}">${escapeHtml(altText)}</title>`);
    }
    return newSvgString;
}

function getFilterRectInPixels(layout, shadow) {
    const {
        blurRadius,
        x,
        y
    } = shadow;
    // STD to pixel ~ STD value * 3 , we are multiplying by 6 for both sides
    const blurSpread = blurRadius * 6;
    const filterAttr = {
        x: Math.min(0, x) - blurSpread / 2,
        y: Math.min(0, y) - blurSpread / 2,
    };
    let res = `x="${filterAttr.x}" y="${filterAttr.y}"`;
    if (layout != null) {
        // In bolt the width and height values are only relevant in the classic editor. In EditorX they end up as NaN
        // In order to have parity with the Bolt implementation, we leave width and height undefined,
        // We avoid NaN values because it results in console errors
        const width = layout.width + blurSpread + Math.abs(x);
        const height = layout.height + blurSpread + Math.abs(y);
        res += ` width="${width}" height="${height}"`;
    }
    return res;
}

function getShadowFilter(filterId, shadow, layout, hexColor, mergeGraphic) {
    const filterString = (0, svgFilters_1.getShadow)(filterId, Object.assign(Object.assign({}, shadow), {
        color: hexColor,
        mergeGraphic
    }));
    return filterString.replace(/<filter /, `<filter ${getFilterRectInPixels(layout, shadow)} filterUnits="userSpaceOnUse" `);
}

function getViewBoxFromData(svgInfo, properties = {}) {
    const {
        svgType,
        viewBox,
        bbox
    } = svgInfo;
    const {
        preserveViewBox
    } = properties;
    if (svgType !== SVG_TYPES.UGC && !preserveViewBox && bbox) {
        return bbox;
    }
    return viewBox;
}

function getScaledSvgViewBox(svgString, svgInfo, properties = {}) {
    var _a;
    if (svgString) {
        const {
            svgType,
            viewBox,
            bbox
        } = svgInfo;
        const {
            preserveViewBox,
            displayMode,
            aspectRatio
        } = properties;
        const preserveAspectRatio = aspectRatio || (displayMode === 'stretch' ? 'none' : 'xMidYMid meet');
        let svgTag = (_a = svgString.match(svgTagMatcher)) === null || _a === void 0 ? void 0 : _a[0];
        if (svgTag) {
            if (preserveAspectRatioMatcher.test(svgTag)) {
                svgString = svgString.replace(svgTag, svgTag.replace(preserveAspectRatioMatcher, `$1${preserveAspectRatio}$3`));
            } else {
                svgString = svgString.replace(/<svg/, `<svg preserveAspectRatio="${preserveAspectRatio}"`);
            }
        } else {
            // no top svg tag so bail out
            return svgString;
        }
        if (!viewBoxMatcher.test(svgTag)) {
            if (svgType === SVG_TYPES.UGC && viewBox) {
                svgString = svgString.replace(/<svg/, `<svg viewBox="${viewBox}"`);
            }
            if (svgType !== SVG_TYPES.UGC && bbox) {
                svgString = svgString.replace(/<svg/, `<svg viewBox="${bbox}"`);
            }
        }
        if (svgType !== SVG_TYPES.UGC && !preserveViewBox && bbox) {
            svgTag = svgString.match(svgTagMatcher)[0];
            svgString = svgString.replace(svgTag, svgTag.replace(viewBoxMatcher, `$1${bbox}$3`));
        }
    }
    return svgString;
}
exports.getScaledSvgViewBox = getScaledSvgViewBox;

function wrapWithShadow({
    compId,
    svgString,
    layout,
    colorsMap,
    shadow,
    shadowOnly = false,
}) {
    if (shadow && shadow.color) {
        const filterId = `${compId}-shadow`;
        const hexColor = (0, color_1.getFromColorMap)(shadow.color, colorsMap);
        const shadowFilter = getShadowFilter(filterId, shadow, layout, hexColor, !shadowOnly);
        const modifiedContent = removeWidthAndHeight(svgString);
        return `
          <svg height="100%" width="100%">
              <defs>${shadowFilter}</defs>
              <g filter="url(#${filterId})">
                  ${modifiedContent}
              </g>
          </svg>
      `;
    }
    return svgString;
}

function getCSSDropShadow(shadow, colorsMap) {
    if (shadow && shadow.color && shadow.opacity) {
        const hexColor = (0, color_1.getFromColorMap)(shadow.color, colorsMap);
        const opacity = Math.round(shadow.opacity * 255).toString(16);
        return `drop-shadow(${shadow.x}px ${shadow.y}px ${shadow.blurRadius}px ${hexColor}${opacity.padStart(2, '0')})`;
    }
    return '';
}
exports.getCSSDropShadow = getCSSDropShadow;

function getCSSStrokeAdjustments(strokeWidth) {
    if (strokeWidth) {
        return {
            svgCalculatedPadding: `${Math.floor(strokeWidth / 2)}px ${Math.ceil(strokeWidth / 2)}px ${Math.ceil(strokeWidth / 2)}px ${Math.floor(strokeWidth / 2)}px`,
            svgCalculatedWidth: `calc(100% - ${strokeWidth}px)`,
            svgCalculatedHeight: `calc(100% - ${strokeWidth}px)`,
        };
    }
    return {};
}
exports.getCSSStrokeAdjustments = getCSSStrokeAdjustments;
const FLIP_DATA_TO_TRANSFORM = {
    x: 'scale(-1, 1)',
    y: 'scale(1, -1)',
    xy: 'scale(-1, -1)',
    none: '',
};

function getFlippedSVG(svgString, flip) {
    const topSvg = svgString.match(svgTagMatcher);
    const transform = FLIP_DATA_TO_TRANSFORM[flip] || '';
    if (topSvg && transform) {
        const styleMatch = topSvg[0].match(styleAttributeMatcher);
        let replacement = `$1 style="transform: ${transform};"$2`;
        if (styleMatch) {
            const transformMatch = styleMatch[1].match(styleTransformMatcher);
            if (transformMatch) {
                replacement = topSvg[0].replace(styleMatch[0], styleMatch[0].replace(transformMatch[0], `transform: ${transform} ${transformMatch[1]}`));
            } else {
                replacement = topSvg[0].replace(styleMatch[0], `style="transform: ${transform}; ${styleMatch[1]}"`);
            }
        }
        return svgString.replace(svgTagMatcher, replacement);
    }
    return svgString;
}

function getSvgContentForMask(svgString, svgInfo, flip) {
    const content = getScaledSvgViewBox(svgString, svgInfo, {
        displayMode: 'stretch'
    });
    // we must have the transform style inlined inside the SVG content
    return getFlippedSVG(content, flip);
}
exports.getSvgContentForMask = getSvgContentForMask;

function addSvgStyleNode(svgString, defsValue) {
    if (svgString && defsValue) {
        return svgString.replace(/(<svg[^>]*>)/, `$1<defs><style>${defsValue}</style></defs>`);
    }
    return svgString;
}
const DEFAULT_COLOR = '#242323';
const pickValidColors = (obj) => Object.keys(obj).reduce((result, key) => {
    const colorValue = obj[key];
    if ((0, color_1.isColor)(colorValue) || (0, color_1.isThemeColor)(colorValue)) {
        result[key] = colorValue;
    }
    return result;
}, {});
const transformVectorImage = (rawSvg, {
    altText,
    compId,
    svgInfo,
    properties,
    layout,
    shadow,
    isResponsive,
    colorsMap,
    overrideColors: overrideColorsInuput,
}) => {
    const overrideColors = pickValidColors(overrideColorsInuput || {});

    function withA11y(svgString) {
        return addA11yAttributes(svgString, compId, altText);
    }

    function withScaledViewBox(svgString) {
        return getScaledSvgViewBox(svgString, svgInfo, properties);
    }

    function withShadowFilter(svgString) {
        return wrapWithShadow({
            compId,
            svgString,
            layout: isResponsive ? null : layout,
            colorsMap,
            shadow,
        });
    }

    function withTintColors(svgString) {
        const rawColor = (overrideColors && overrideColors.color1) || DEFAULT_COLOR;
        const color = (0, color_1.getFromColorMap)(rawColor, colorsMap);
        return svgInfo.svgType === SVG_TYPES.TINT ? transformToTintColors(svgString, color) : svgString;
    }

    function withCssOverrides(svgString) {
        const shouldOverrideColors = svgInfo.svgType === SVG_TYPES.COLOR && Object.keys(overrideColors).length > 0;
        if (shouldOverrideColors) {
            const colors = Object.entries(overrideColors)
                .map(([colorName, rawColor]) => {
                    const resolvedColor = (0, color_1.getFromColorMap)(rawColor, colorsMap);
                    const index = colorName.replace('color', '');
                    return `${(0, hoverBoxUtils_1.compIdToCssSelector)(compId, true)} svg [data-color="${index}"] {fill: ${resolvedColor};}`;
                })
                .join('\n');
            return addSvgStyleNode(svgString, colors);
        }
        return svgString;
    }
    const content = withScaledViewBox(withTintColors(withA11y(rawSvg)));
    return withCssOverrides(isResponsive ? content : withShadowFilter(content));
};
exports.transformVectorImage = transformVectorImage;
const HAIRLINE_FIX_FACTOR = 1;

function invertSvgContent(svgContent, x, y, width, height) {
    var _a, _b;
    const pathDRe = /<path.*\s*d="([^"]+)"/;
    const pathTagRe = /(<path)[^>]*>/;
    const pathTag = ((_a = svgContent.match(pathTagRe)) === null || _a === void 0 ? void 0 : _a[1]) || '';
    const pathData = ((_b = svgContent.match(pathDRe)) === null || _b === void 0 ? void 0 : _b[1]) || '';
    const rectPathSuffix = `M${x},${y - HAIRLINE_FIX_FACTOR} h${width} v${height + HAIRLINE_FIX_FACTOR} h${-width} Z`;
    return svgContent
        .replace(pathData, `${pathData} ${rectPathSuffix}`)
        .replace(pathTag, `${pathTag} fill-rule="evenodd"`);
}

function trimSvgContents(svgContent) {
    const svgContentStartRe = /^(.*\s*)<svg/;
    const svgContentEndRe = /<\/svg>(\s*)$/;
    return svgContent.replace(svgContentStartRe, '<svg').replace(svgContentEndRe, '</svg>');
}
const getShapeDividerImageCss = (rawSvg, {
    color,
    height,
    keepAspectRatio,
    compId,
    side,
    shouldRepeat,
    repeatCount,
    shouldInvert,
    svgInfo,
}) => {
    const aspectRatio = keepAspectRatio ? (shouldRepeat ? 'xMinYMax meet' : 'xMidYMax slice') : 'none';
    const viewBox = getViewBoxFromData(svgInfo);
    if (!rawSvg || !viewBox) {
        return {
            image: rawSvg ? encodeSVG(rawSvg) : '',
        };
    }
    const [vbX, vbY, vbWidth, vbHeight] = viewBox.split(' ').map((n) => parseFloat(n));
    const viewBoxOverride = `${vbX} ${vbY} ${vbWidth} ${vbHeight}`;
    const scaledSvg = getScaledSvgViewBox(rawSvg, {
        svgType: svgInfo.svgType,
        bbox: viewBoxOverride,
        viewBox: viewBoxOverride
    }, {
        aspectRatio
    });
    const uniqueId = `${compId}-${side}`;
    const trimmedContent = trimSvgContents(scaledSvg);
    const processedSvgContent = shouldInvert ?
        invertSvgContent(trimmedContent, vbX, vbY, vbWidth, vbHeight) :
        trimmedContent;
    const invertingTransform = shouldInvert ?
        `#${uniqueId} > g { transform: scaleY(-1) translateY(${-(2 * vbY + vbHeight)}px); } ` :
        '';
    const pathColoring = svgInfo.svgType === 'color' && !svgInfo.color2 ? `, #${uniqueId} [data-color="1"] ` : '';
    const svgStyle = `${invertingTransform}#${uniqueId}${pathColoring} { fill: ${color}; }`;
    const image = encodeSVG(removeWidthAndHeight(addSvgStyleNode(setSvgId(processedSvgContent, uniqueId), svgStyle), {
        width: vbWidth.toFixed(2),
        height: vbHeight.toFixed(2),
    }));
    const size = `${
    // !NOTE: assuming height is in px!
    // When in aspect-ratio we're calculating width instead of `auto`
    // because of rendering bugs in Safari (vertical hairlines
    // between horizontally repeated SVG as background-image).
    // Since we have fixed height - use it instead of 100%
    // Also limit fraction digits to 2 repeat in stretch - seems to do better in Safari - same issue
    keepAspectRatio
        ? `${Math.ceil((vbWidth * parseInt(height, 10)) / vbHeight)}px`
        : `${((1 / (repeatCount + 1)) * 100).toFixed(2)}%`} 100%`;
    // const position = `center center`
    return {
        image,
        size,
    };
};
exports.getShapeDividerImageCss = getShapeDividerImageCss;
const getFontFamilyFontsFromSvg = (svgString) => {
    const regex = /font-family=['"](.*?)['"]/gi;
    let match;
    const fonts = [];
    do {
        match = regex.exec(svgString);
        if (match && match[1]) {
            const font = match[1].split(',').map((f) => f.replace(/'/g, '').trim());
            fonts.push(font);
        }
    } while (match);
    return fonts;
};
exports.getFontFamilyFontsFromSvg = getFontFamilyFontsFromSvg;
const buildSvgUrlFactory = () => {
    const addTrailingSlashIfMissing = (val) => (val.endsWith('/') ? val : `${val}/`);
    const getSvgBaseUrl = (mediaRootUrl) => `${addTrailingSlashIfMissing(mediaRootUrl)}shapes/`;
    const svgIdToUri = (svgId) => {
        const partsArr = svgId.replace(/^.*\//, '').split('.');
        const version = partsArr[1] === 'v1' ? 1 : 2;
        const svgHash = partsArr[2].replace(/svg_/i, '');
        const svgName = partsArr[3];
        return `${svgHash + (version === 1 ? `_svgshape.v1.${svgName}` : '')}.svg`;
    };
    return {
        getSvgBaseUrl,
        buildSvgUrl: (mediaRootUrl, svgId) => {
            if (/^svgshape\.v[12]/.test(svgId)) {
                const svgUri = svgIdToUri(svgId);
                return `${getSvgBaseUrl(mediaRootUrl)}${svgUri}`;
            }
            return `${getSvgBaseUrl(mediaRootUrl)}${svgId}`;
        },
    };
};
exports.buildSvgUrlFactory = buildSvgUrlFactory;
//# sourceMappingURL=index.js.map