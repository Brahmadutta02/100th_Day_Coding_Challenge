"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getProperties = exports.interpolate = void 0;
const tslib_1 = require("tslib");
const svgFiltersParts_1 = require("./svgFiltersParts");

function attrToString(key, value) {
    return value || value === 0 ? `${key}="${value}"` : '';
}

function attrsObjectToString(attrs) {
    return Object.keys(attrs)
        .map((key) => attrToString(key, attrs[key]))
        .join(' ');
}

function filterWrapperTemplate({
    id,
    content,
    attrs = {}
}) {
    // the redundant identity <feComponentTransfer/> in start and end
    // are for fixing old Webkit bug that caused it to ignore color-interpolation-filters="sRGB"
    return `<filter id="${id}" color-interpolation-filters="sRGB" ${attrsObjectToString(attrs)}>
    <feComponentTransfer result="srcRGB"/>
    ${content}
    <feComponentTransfer/>
</filter>`;
}

function identity({
    inAttr
}) {
    return `<feColorMatrix ${attrToString('in', inAttr)}/>`;
}

function contrast({
    value
}) {
    return `<feComponentTransfer>${(0, svgFiltersParts_1.getContrast)(value)}</feComponentTransfer>`;
}

function brightness({
    value,
    result
}) {
    return `<feComponentTransfer ${attrToString('result', result)}>${(0, svgFiltersParts_1.getBrightness)(value)}</feComponentTransfer>`;
}

function saturation({
    value,
    inAttr,
    result
}) {
    return `<feColorMatrix type="saturate" values="${value}" ${inAttr ? `in="${inAttr}"` : ''}${result ? `result="${result}"` : ''}/>`;
}

function sepia({
    value
}) {
    return `<feColorMatrix type="matrix" values="${(0, svgFiltersParts_1.getSepia)(value)}"/>`;
}

function hue({
    value
}) {
    return `<feColorMatrix type="hueRotate" values="${value}"/>`;
}

function color({
    value,
    inAttr,
    result
}) {
    const hexColor = typeof value === 'string' ? value : value.color;
    const opacity = typeof value === 'object' && typeof value.opacity !== 'undefined' ? value.opacity : 1;
    return `<feColorMatrix type="matrix" values="${(0, svgFiltersParts_1.getColor)((0, svgFiltersParts_1.hex2RgbNorm)(hexColor), opacity)}" ${inAttr ? `in="${inAttr}"` : ''}${result ? `result="${result}"` : ''}/>`;
}

function tint({
    value
}) {
    return `<feColorMatrix type="matrix" values="${(0, svgFiltersParts_1.getTint)((0, svgFiltersParts_1.hex2RgbNorm)(value))}"/>`;
}

function blur({
    value,
    inAttr
}) {
    return `<feGaussianBlur stdDeviation="${value}" ${inAttr ? `in="${inAttr}"` : ''}/>`;
}

function alpha({
    value,
    inAttr,
    result
}) {
    return `<feComponentTransfer ${attrToString('in', inAttr)} ${attrToString('result', result)}>${(0, svgFiltersParts_1.getAlpha)(value)}</feComponentTransfer>`;
}

function offset({
    value,
    inAttr,
    result
}) {
    return `<feOffset dx="${value.x}" dy="${value.y}" ${inAttr ? `in="${inAttr}"` : ''}${result ? `result="${result}"` : ''}/>`;
}

function blend({
    value,
    inAttr,
    in2Attr,
    result
}) {
    return `<feBlend mode="${value}" in="${inAttr}" in2="${in2Attr}" ${attrToString('result', result)}/>`;
}

function composite({
    value,
    inAttr,
    in2Attr,
    result
}) {
    return `<feComposite operator="${value}" in="${inAttr}" in2="${in2Attr}" ${attrToString('result', result)}/>`;
}

function duotone({
    value: {
        dark,
        light
    },
    inAttr,
    result
}) {
    return `${saturation({ value: 0 })}
<feColorMatrix type="matrix" values="${(0, svgFiltersParts_1.getDoutone)((0, svgFiltersParts_1.hex2RgbNorm)(light), (0, svgFiltersParts_1.hex2RgbNorm)(dark))}" ${inAttr ? `in="${inAttr}"` : ''}${result ? `result="${result}"` : ''}/>`;
}

function luma({
    value: {
        dark,
        light
    },
    result
}) {
    return `<feColorMatrix type="matrix" values="${(0, svgFiltersParts_1.getLumaMatrix)(light, dark)}" ${result ? `result="${result}"` : ''}/>`;
}

function shadow(_a) {
    var _b = _a.value,
        {
            blurRadius,
            mergeGraphic
        } = _b,
        rest = (0, tslib_1.__rest)(_b, ["blurRadius", "mergeGraphic"]);
    return `${blur({ value: blurRadius, inAttr: 'SourceAlpha' })}
${offset({ value: rest })}
${color({ value: rest })}
${mergeGraphic
        ? `<feMerge>
    <feMergeNode/>
    <feMergeNode in="SourceGraphic"/>
</feMerge>`
        : ''}`;
}
const filterComponentTempaltesWithNumber = {
    blur,
    saturation,
    contrast,
    brightness,
    sepia,
    hue,
    alpha,
};
const filterComponentTempaltesWithString = {
    blend,
    color,
    composite,
    tint,
};
const filterComponentTempaltes = {
    duotone,
    shadow,
    color,
    offset,
};

function getFilterValue(key, value, overrides) {
    if (key === 'duotone') {
        return {
            light: ('duotoneLight' in overrides && overrides.duotoneLight) || value.light,
            dark: ('duotoneDark' in overrides && overrides.duotoneDark) || value.dark,
        };
    } else if (key in overrides) {
        return overrides[key];
    }
    return value;
}

function interpolate(id, filterDefinition, overrides, attrs) {
    const content = filterDefinition
        .map((effect) => {
            const {
                key,
                value
            } = effect;
            const filterValue = getFilterValue(key, value, overrides);
            const arg = Object.assign(Object.assign({}, effect), {
                value: filterValue
            });
            if (typeof filterValue === 'number') {
                return filterComponentTempaltesWithNumber[key](arg);
            } else if (typeof filterValue === 'string') {
                return filterComponentTempaltesWithString[key](arg);
            } else if (key === 'luma') {
                return luma(arg);
            } else if (key === 'identity') {
                return identity(arg);
            } else {
                return filterComponentTempaltes[key](arg);
            }
        })
        .join('\n');
    return filterWrapperTemplate({
        id,
        content,
        attrs
    });
}
exports.interpolate = interpolate;

function getProperties(filterDefinition, overrides) {
    return filterDefinition.map((effect) => {
        const {
            key,
            value
        } = effect;
        return {
            [key]: getFilterValue(key, value, overrides)
        };
    });
}
exports.getProperties = getProperties;
//# sourceMappingURL=svgFiltersTemplates.js.map