import _extends from "@babel/runtime/helpers/extends";
import {
    normalizeWixColorFormat,
    omit
} from '@wix/color-kit';
import {
    generate as generateGradient
} from '@wix/css-gradient-generator';
import {
    getData
} from '@wix/image-kit';
const TITLE_LENGTH_LIMIT = 100;

const getStaticMediaUrl = () => {
    var _ref, _serviceTopology;

    return (_ref = typeof window !== 'undefined' && ((_serviceTopology = window.serviceTopology) == null ? void 0 : _serviceTopology.staticMediaUrl)) != null ? _ref : '';
};

const snakeToCamel = str => str.toLowerCase().replace(/(_\w)/g, res => res[1].toUpperCase());

const getObjectValueByKey = (object, key) => object[key] || object[snakeToCamel(key)];

const url2uri = url => url.replace(/^(.*[/])/, ''); // Variant of santa-core/santa-core-utils/src/coreUtils/core/urlUtils.js


const joinURL = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    return args.map(arg => arg.replace(/(^\/)|(\/$)/g, '')).join('/');
};

const parseVideoPosters = fileOutput => fileOutput.image.map(image => url2uri(image.url));

const fixMediaTitleLength = (value, lengthLimit) => {
    const CHARS_TO_ADD = '...';
    const NUM_OF_CHARS_TO_KEEP = 3;

    if (value.length <= lengthLimit) {
        return value;
    }

    const arr = value.split('');
    const numOfCharsToRemove = value.length - lengthLimit + CHARS_TO_ADD.length;
    const isFileTypeSuffix = value.lastIndexOf('.') > value.length - numOfCharsToRemove - NUM_OF_CHARS_TO_KEEP;
    const fileTypeSuffixIndex = isFileTypeSuffix ? value.lastIndexOf('.') : value.length - 1;
    const removeIndex = fileTypeSuffixIndex - numOfCharsToRemove - NUM_OF_CHARS_TO_KEEP;
    arr.splice(removeIndex, numOfCharsToRemove, CHARS_TO_ADD);
    return arr.join('');
};

const parseVideoQualities = fileOutput => {
    var _fileOutput$storyboar;

    const mp4Videos = fileOutput.video.filter(_ref2 => {
        let format = _ref2.format;
        return format === 'mp4';
    });
    const storyboard = (_fileOutput$storyboar = fileOutput.storyboard) == null ? void 0 : _fileOutput$storyboar.find(_ref3 => {
        let format = _ref3.format;
        return format === 'mp4';
    });
    const qualities = mp4Videos.map(_ref4 => {
        let width = _ref4.width,
            height = _ref4.height,
            quality = _ref4.quality,
            url = _ref4.url;
        return {
            width,
            height,
            quality,
            url
        };
    });

    if (storyboard) {
        qualities.push({
            quality: 'storyboard',
            width: storyboard.width,
            height: storyboard.height,
            url: storyboard.url
        });
    }

    return qualities;
};

const parseAdaptiveUrls = fileOutput => {
    const adaptiveVideo = getObjectValueByKey(fileOutput, 'adaptive_video');
    return adaptiveVideo.map(item => {
        return {
            format: item.format,
            url: item.url
        };
    });
};

const parseMediaFeatures = fileInfo => {
    var _fileInfo$tags;

    const mediaFeatures = [];

    if ((_fileInfo$tags = fileInfo.tags) != null && _fileInfo$tags.includes('_mp4_alpha')) {
        mediaFeatures.push('alpha');
    }

    return mediaFeatures.length ? mediaFeatures : null;
};

export const alignTypes = {
    CENTER: 'center',
    TOP: 'top',
    TOP_LEFT: 'top_left',
    TOP_RIGHT: 'top_right',
    BOTTOM: 'bottom',
    BOTTOM_LEFT: 'bottom_left',
    BOTTOM_RIGHT: 'bottom_right',
    LEFT: 'left',
    RIGHT: 'right'
};
export const fittingTypes = {
    SCALE_TO_FILL: 'fill',
    SCALE_TO_FIT: 'fit',
    STRETCH: 'stretch',
    ORIGINAL_SIZE: 'original_size',
    TILE: 'tile',
    TILE_HORIZONTAL: 'tile_horizontal',
    TILE_VERTICAL: 'tile_vertical',
    FIT_AND_TILE: 'fit_and_tile',
    LEGACY_STRIP_TILE: 'legacy_strip_tile',
    LEGACY_STRIP_TILE_HORIZONTAL: 'legacy_strip_tile_horizontal',
    LEGACY_STRIP_TILE_VERTICAL: 'legacy_strip_tile_vertical',
    LEGACY_STRIP_SCALE_TO_FILL: 'legacy_strip_fill',
    LEGACY_STRIP_SCALE_TO_FIT: 'legacy_strip_fit',
    LEGACY_STRIP_FIT_AND_TILE: 'legacy_strip_fit_and_tile',
    LEGACY_STRIP_ORIGINAL_SIZE: 'legacy_strip_original_size',
    LEGACY_ORIGINAL_SIZE: 'actual_size',
    LEGACY_FIT_WIDTH: 'fitWidth',
    LEGACY_FIT_HEIGHT: 'fitHeight',
    LEGACY_FULL: 'full',
    LEGACY_BG_FIT_AND_TILE: 'legacy_tile',
    LEGACY_BG_FIT_AND_TILE_HORIZONTAL: 'legacy_tile_horizontal',
    LEGACY_BG_FIT_AND_TILE_VERTICAL: 'legacy_tile_vertical',
    LEGACY_BG_NORMAL: 'legacy_normal'
};
export const MEDIA_TYPES = {
    COLOR: 'Color',
    IMAGE: 'Image',
    VIDEO: 'WixVideo'
};
export const BG_VIDEO_DEFAULTS = {
    opacity: 1,
    autoplay: true,
    loop: true,
    preload: 'auto',
    mute: true
};
export const MEDIA_PLAYER_DEFAULTS = {
    opacity: 1,
    preload: 'auto'
};
export const COLOR_DEFAULTS = {
    mediaRef: null,
    colorOpacity: 1,
    colorOverlay: '',
    colorOverlayOpacity: 0,
    imageOverlay: null,
    filterEffect: null,
    scrollType: 'none',
    alignType: alignTypes.CENTER,
    fittingType: fittingTypes.SCALE_TO_FILL
};
export const FALLBACK_GRADIENT = {
    type: 'GradientLinear',
    angle: 90,
    colorStops: [{
        size: {
            value: 0,
            type: 'percentage'
        },
        color: '#000',
        opacity: 1
    }, {
        size: {
            value: 100,
            type: 'percentage'
        },
        color: '#fff'
    }]
};
export const mediaManagerDefaultPaths = {
    Color: 'public/6ae967c404004038b5e84dd0a6ab2b65/73d89c137a524437880b113939ca24c3',
    // fallback to image
    Image: 'public/6ae967c404004038b5e84dd0a6ab2b65/73d89c137a524437880b113939ca24c3',
    WixVideo: 'public/8e256233-1752-4026-9341-54036e7f875e/d6b6b972-952c-4ab0-b46a-a6c05a0a94a5'
};
export const payloadMediaTypes = {
    IMAGE: 'picture',
    VIDEO: 'video'
};
export const getIdFromUrl = fileUrl => {
    var _result$;

    const result = fileUrl.match(/(?:\/|^)([0-9a-fA-F_]+)(?:\/|$)/) || [];
    return (_result$ = result[1]) != null ? _result$ : '';
};
export const parseVideoFileInfo = (fileInfo, info) => {
    var _fileOutput$video$0$f, _fileOutput$video$;

    const fileInput = getObjectValueByKey(fileInfo, 'file_input');
    const fileOutput = getObjectValueByKey(fileInfo, 'file_output');
    const videoId = getIdFromUrl(getObjectValueByKey(fileInfo, 'file_name') || getObjectValueByKey(fileInfo, 'file_url'));
    const title = fixMediaTitleLength(fileInfo.title, TITLE_LENGTH_LIMIT);
    const qualities = parseVideoQualities(fileOutput);
    const adaptiveVideo = parseAdaptiveUrls(fileOutput);
    const mediaFeatures = parseMediaFeatures(fileInfo); // parse poster - get the first item in data

    const imageData = fileOutput.image[0];
    const posterImageRef = {
        type: 'Image',
        width: imageData.width,
        height: imageData.height,
        uri: url2uri(imageData.url),
        description: info.path ? info.path : undefined
    };
    return {
        type: 'WixVideo',
        title,
        videoId,
        duration: +(fileInput.duration / 1000).toFixed(2),
        posterImageRef,
        generatedPosters: parseVideoPosters(fileOutput),
        qualities,
        adaptiveVideo,
        artist: {
            name: fileInfo.vendor || '',
            id: fileInfo.reference || ''
        },
        hasAudio: getObjectValueByKey(fileOutput.video[0], 'audio_bitrate') !== -1,
        fps: ((_fileOutput$video$0$f = (_fileOutput$video$ = fileOutput.video[0]) == null ? void 0 : _fileOutput$video$.fps) != null ? _fileOutput$video$0$f : '').toString(),
        mediaFeatures: mediaFeatures || []
    };
};
export const getVideoBackgroundObject = (fileInfo, info) => {
    const mediaObject = parseVideoFileInfo(fileInfo, info);
    return _extends({}, BG_VIDEO_DEFAULTS, mediaObject);
};
export function getMediaPlayerVideoObject(fileInfo, info) {
    const mediaObject = parseVideoFileInfo(fileInfo, info);
    return _extends({}, mediaObject, MEDIA_PLAYER_DEFAULTS);
}
export function getVideoPosterObject(videoId, uri, width, height) {
    return {
        type: 'WixVideo',
        videoId,
        posterImageRef: {
            type: 'Image',
            uri,
            width,
            height
        }
    };
}
export function getImageBackgroundObject(fileInfo, info) {
    return {
        type: 'Image',
        uri: getObjectValueByKey(fileInfo, 'file_name'),
        title: fixMediaTitleLength(fileInfo.title, TITLE_LENGTH_LIMIT),
        description: info.path,
        width: fileInfo.width,
        height: fileInfo.height,
        artist: {
            name: fileInfo.vendor || '',
            id: fileInfo.reference || ''
        }
    };
}
export function getImageBackgroundObjectFromMediaStudioFile(mediaStudioFileInfo) {
    return {
        type: 'Image',
        uri: mediaStudioFileInfo.id,
        title: fixMediaTitleLength(mediaStudioFileInfo.name, TITLE_LENGTH_LIMIT),
        description: 'private',
        // Media Studio always saves to private media
        width: mediaStudioFileInfo.width,
        height: mediaStudioFileInfo.height,
        artist: {
            name: '',
            id: ''
        } // This is information is not available in Media Studio

    };
}
export function isSmallerFromContainer(width, height, containerWidth, containerHeight) {
    return width < containerWidth && height < containerHeight;
}
export function getMediaType(background) {
    var _background$mediaRef$, _background$mediaRef;

    return (_background$mediaRef$ = background == null ? void 0 : (_background$mediaRef = background.mediaRef) == null ? void 0 : _background$mediaRef.type) != null ? _background$mediaRef$ : MEDIA_TYPES.COLOR;
}
/**
 * removes overlayData from BackgroundMedia data
 * MUTATES DATA!
 */

export function clearOverlayData(data) {
    // todo: should be modified if we want to 'support' overlay for Image type and mobile view
    data.ref.colorOverlay = '';
    data.ref.colorOverlayOpacity = 0;
    data.ref.imageOverlay = null;
}
/**
 * return showStoryboard value , defaults to 'time'
 */

export function getStoryboardDisplayValue(videoData, currentValue) {
    if (currentValue && currentValue !== 'videoAndTime') {
        return currentValue;
    }

    const storyboardItem = videoData.qualities.find(quality => quality === 'storyboard');

    if (storyboardItem && currentValue) {
        return 'videoAndTime';
    }

    return 'time';
}
export function getColorValue(colorResolver, color) {
    var _color;

    color = (_color = color) != null ? _color : '';
    return color.match('color') ? colorResolver(color.replace(/[{}]/g, '')) : color;
}
export function getOverlayStyle(data, colorResolver) {
    const color = getColorValue(colorResolver, data.colorOverlay);

    const _normalizeWixColorFor = normalizeWixColorFormat(color),
        r = _normalizeWixColorFor[0],
        g = _normalizeWixColorFor[1],
        b = _normalizeWixColorFor[2];

    const opacity = data.colorOverlayOpacity || 0;
    return {
        backgroundImage: data.imageOverlay ? "url(" + getMediaURl(data.imageOverlay.uri) + ")" : null,
        backgroundColor: color ? "rgba(" + r + ", " + g + ", " + b + ", " + opacity + ")" : null
    };
}
export function generateColorLayer(fill, opacity) {
    if (opacity === void 0) {
        opacity = 1;
    }

    const type = fill.type + "Layer";
    return {
        type,
        opacity,
        fill
    };
}
export function getColorOrGradient(data) {
    var _data$colorLayers, _data$color;

    const fill = ((_data$colorLayers = data.colorLayers) == null ? void 0 : _data$colorLayers[0].fill) || ((_data$color = data.color) == null ? void 0 : _data$color.replace(/[{}]/g, ''));
    return typeof fill !== 'string' && (fill == null ? void 0 : fill.type) === 'SolidColor' ? fill.color : fill;
}
export function getResolvedColor(color, colorResolver) {
    if (typeof color === 'string') {
        return colorResolver(color);
    } else if (color != null && color.type) {
        return generateGradient(color, {
            resolveColor: colorResolver
        });
    }

    return color;
}
export function getFirstColorStopColor(value, colorResolver) {
    let color;

    if (typeof value === 'string') {
        color = value;
    } else if ((value == null ? void 0 : value.type) === 'GradientMesh') {
        var _value$gradients;

        color = (_value$gradients = value.gradients) == null ? void 0 : _value$gradients[0].colorStops[0].color;
    } else {
        var _value$colorStops, _value$colorStops$;

        color = value == null ? void 0 : (_value$colorStops = value.colorStops) == null ? void 0 : (_value$colorStops$ = _value$colorStops[0]) == null ? void 0 : _value$colorStops$.color;
    }

    return getResolvedColor(color || '', colorResolver);
}
export function getColorOpacityValue(data) {
    var _ref5, _data$colorLayers$0$o, _data$colorLayers2;

    return (_ref5 = (_data$colorLayers$0$o = (_data$colorLayers2 = data.colorLayers) == null ? void 0 : _data$colorLayers2[0].opacity) != null ? _data$colorLayers$0$o : data.colorOpacity) != null ? _ref5 : 1;
}
export function getNewColorLayers(data, value, opacity) {
    var _opacity, _value2;

    if (value === void 0) {
        value = getColorOrGradient(data);
    }

    let colorLayers;
    opacity = (_opacity = opacity) != null ? _opacity : getColorOpacityValue(data);

    if (typeof value === 'string') {
        var _value;

        colorLayers = [generateColorLayer({
            type: 'SolidColor',
            color: (_value = value) != null ? _value : '#FFFFFF'
        }, opacity)];
    } else if ((_value2 = value) != null && _value2.type) {
        colorLayers = [generateColorLayer(value, opacity)];
    } else if (Array.isArray(value)) {
        colorLayers = [generateColorLayer({
            type: 'GradientMesh',
            gradients: value
        }, opacity)];
    } else {
        // eslint-disable-next-line no-console
        console.error(value, 'is not a type we can set to a colorLayer');
    }

    return colorLayers;
}

const omitIdAndMetaData = obj => omit(obj, ['id', 'metaData']);

export const removeIdsAndMetaDataFromBg = backgroundData => {
    const background = omitIdAndMetaData(backgroundData);

    if (backgroundData.imageOverlay) {
        const imageOverlay = omitIdAndMetaData(backgroundData.imageOverlay);
        background.imageOverlay = imageOverlay;
    }

    if (backgroundData.mediaRef) {
        const mediaRef = omitIdAndMetaData(backgroundData.mediaRef);

        if (backgroundData.mediaRef.posterImageRef) {
            const posterImageRef = omitIdAndMetaData(backgroundData.mediaRef.posterImageRef);
            mediaRef.posterImageRef = posterImageRef;
        }

        background.mediaRef = mediaRef;
    }

    return background;
};
export function getImageDisplayData(_ref6) {
    let fittingType = _ref6.fittingType,
        alignType = _ref6.alignType,
        imageUri = _ref6.imageUri,
        srcImageWidth = _ref6.srcImageWidth,
        srcImageHeight = _ref6.srcImageHeight,
        containerWidth = _ref6.containerWidth,
        containerHeight = _ref6.containerHeight,
        _ref6$quality = _ref6.quality,
        quality = _ref6$quality === void 0 ? 85 : _ref6$quality,
        _ref6$pixelAspectRati = _ref6.pixelAspectRatio,
        pixelAspectRatio = _ref6$pixelAspectRati === void 0 ? window.devicePixelRatio : _ref6$pixelAspectRati,
        _ref6$htmlTag = _ref6.htmlTag,
        htmlTag = _ref6$htmlTag === void 0 ? 'bg' : _ref6$htmlTag;
    const src = {
        id: imageUri,
        width: srcImageWidth,
        height: srcImageHeight
    };
    const target = {
        width: containerWidth,
        height: containerHeight,
        alignment: alignType,
        htmlTag,
        pixelAspectRatio
    };
    return getData(fittingType, src, target, {
        quality
    });
}
export function getMediaURl(mediaUri, staticMediaUrlOverride) {
    return "" + joinURL(staticMediaUrlOverride != null ? staticMediaUrlOverride : getStaticMediaUrl(), mediaUri);
}
//# sourceMappingURL=backgroundUtils.js.map