var __rest = (this && this.__rest) || function(s, e) {
    var t = {};
    for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
export const BUNDLE_PREFIX = 'rb_'; // means "registry bundle"
export const LOCAL_NAMESPACE_SUFFIX = '.local';
export function withProdNamespace(namespace) {
    return namespace.replace(LOCAL_NAMESPACE_SUFFIX, '');
}
export function withLocalNamespace(namespace) {
    return `${namespace}${LOCAL_NAMESPACE_SUFFIX}`;
}

function getComponentName(componentName, originalComponentName) {
    if (!componentName) {
        return null;
    }
    if (componentName === originalComponentName || !originalComponentName) {
        return componentName;
    } else {
        return `${componentName.replace(new RegExp(originalComponentName, 'g'), '~')}~${originalComponentName}`;
    }
}
export const getBundleId = (props) => {
    const {
        componentName,
        originalComponentName,
        part,
        namespace = '',
        host,
        batch,
    } = props;
    const name = getComponentName(componentName, originalComponentName);
    if (componentName && part) {
        return `${BUNDLE_PREFIX}${namespace}.${host}[${name}]${part}`;
    } else if (componentName) {
        return `${BUNDLE_PREFIX}${namespace}.${host}[${name}]`;
    } else if (batch) {
        return `${BUNDLE_PREFIX}${namespace}.${host}_${batch}`;
    } else if (part) {
        return `${BUNDLE_PREFIX}${namespace}.${host}~${part}`;
    } else {
        return `${BUNDLE_PREFIX}${namespace}.${host}`;
    }
};
export const getBundleName = (props) => {
    const {
        extension = 'js'
    } = props, rest = __rest(props, ["extension"]);
    return `${getBundleId(rest)}.${extension}`;
};
export const getBundleExtension = (bundleName) => {
    const parsed = bundleName.match(/\.([a-z]+)$/);
    if (!parsed) {
        return null;
    }
    return parsed[1];
};
export const getModuleIdFromBundle = (bundleName) => {
    const extension = getBundleExtension(bundleName);
    return {
        bundleId: extension ?
            bundleName
            .replace(/\.[a-f0-9]{8}/, '')
            .replace(`.chunk`, '')
            .replace(`.bundle`, '')
            .replace(`.min`, '')
            .replace(`.${extension}`, '') :
            null,
        extension,
    };
};
export const parseBundleId = (bundleId) => {
    /**
     * rb_namespace.host
     * rb_namespace.host[componentName]
     * rb_namespace.host[componentName]part
     *
     * Original RegExp with the named groups:
     *
     * /(?<namespace>[^[]+)\.(?<host>[^[]+)(\[(?<componentName>.+)\])?(?<part>[^.]+)?/
     *
     * Some browser still does not support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
     * see `lookbehind assertions` section
     */
    // _____________ns[1]____host[2]___batch[3]____eagerPart[4]___name[5]___part[6]_
    const result = /([^[]+)\.([^[_~]+)(?:_([^[]+)|(?:~([^[]+))?)?(?:\[(.+)\])?([^.]+)?/.exec(bundleId);
    if (!result) {
        return null;
    }
    const [, prefixAndNamespace, host, batch, eagerPart, name, part] = result;
    const namespace = prefixAndNamespace.replace(BUNDLE_PREFIX, '');
    if (batch && (name || part)) {
        return null;
    }
    const [componentName, ...rest] = name ? name.split('~') : [];
    const originalComponentName = rest.pop();
    return {
        namespace: namespace ? namespace : undefined,
        host,
        componentName: name ?
            componentName + rest.map(s => originalComponentName + s).join('') :
            undefined,
        originalComponentName,
        part: part ? part : eagerPart,
        batch,
    };
};
export const parseBundleName = (bundleName) => {
    if (!bundleName.startsWith(BUNDLE_PREFIX)) {
        return null;
    }
    const {
        bundleId,
        extension
    } = getModuleIdFromBundle(bundleName);
    if (bundleId === null || extension === null) {
        return null;
    }
    const parsed = parseBundleId(bundleId);
    return parsed === null ?
        null :
        Object.assign(Object.assign({}, parsed), {
            extension,
            id: bundleId
        });
};
export const getManifestName = ({
    namespace,
    host,
    isDev,
}) => {
    const extension = `${isDev ? '' : '.min'}.json`;
    return `${BUNDLE_PREFIX}${namespace}.${host}.manifest${extension}`;
};
export const parseManifestName = (manifest) => {
    if (!manifest.startsWith(BUNDLE_PREFIX)) {
        return null;
    }
    const result = /(.+)\.manifest(\.min)?\.json$/.exec(manifest.replace(BUNDLE_PREFIX, ''));
    if (!result) {
        return null;
    }
    const [, namespaceAndHost] = result;
    const symbols = namespaceAndHost.split('.');
    const host = symbols.pop();
    const namespace = symbols.join('.');
    return {
        host,
        namespace,
    };
};
export function getLazyFactoryID(id) {
    return `${id}_lazy_factory`;
}
//# sourceMappingURL=bundles.js.map