"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createRegistry = exports.loadContext = exports.isLibraryTopology = exports.withDefaultOptions = void 0;
const editor_elements_conventions_1 = require("@wix/editor-elements-conventions");
const createResourceLoader_1 = require("./loaders/createResourceLoader");
const createManifestAPI_1 = require("./manifest/createManifestAPI");
const createComponentLoaders_1 = require("./loaders/createComponentLoaders");
const loadExternalRegistry_1 = require("./loaders/loadExternalRegistry");
const validateLibraryURL_1 = require("./toolbox/validateLibraryURL");
const utils_1 = require("./utils");

function withDefaultOptions(options) {
    return Object.assign({
        dev: false,
        useScriptsInsteadOfEval: false,
        usePartialManifests: false,
        useExperimentalEval: false,
        useLazyLoadersInit: false
    }, options);
}
exports.withDefaultOptions = withDefaultOptions;
const isLibraryTopology = (library) => {
    return library.hasOwnProperty('namespace') && library.hasOwnProperty('url');
};
exports.isLibraryTopology = isLibraryTopology;
async function loadContext({
    host,
    libraries,
    resourceLoader,
    options,
}) {
    const urls = [];
    const manifests = [];
    libraries.forEach((library, index) => {
        if ((0, exports.isLibraryTopology)(library)) {
            const manifestName = (0, editor_elements_conventions_1.getManifestName)({
                namespace: library.namespace,
                host,
                isDev: false,
            });
            const url = `${library.url}/${manifestName}`;
            urls.push({
                url,
                order: index
            });
        } else {
            manifests.push({
                manifest: (0, createManifestAPI_1.createManifestAPI)(library),
                order: index,
            });
        }
    });
    const loadManifests = () => {
        return Promise.all(urls.map(async ({
            url,
            order
        }) => {
            const manifest = await resourceLoader.fetchLibraryManifest({
                url,
            });
            return {
                order,
                manifest: (0, createManifestAPI_1.createManifestAPI)(manifest),
            };
        }));
    };
    if (!options.usePartialManifests) {
        manifests.push(...(await loadManifests()));
    }
    return {
        manifests,
        urls: urls.map(({
            url
        }) => url),
        loadManifests: options.usePartialManifests ? loadManifests : null,
    };
}
exports.loadContext = loadContext;

function splitLibraries(libraries) {
    return libraries.reduce((acc, lib) => {
        if ((0, exports.isLibraryTopology)(lib) &&
            lib.namespace === loadExternalRegistry_1.EXTERNAL_REGISTRY_OVERRIDE_NAMESPACE) {
            acc.registryOverrideLibrary = lib;
        } else {
            acc.libraries.push(lib);
        }
        return acc;
    }, {
        libraries: [],
        registryOverrideLibrary: null,
    });
}

function filterUntrustedURLs(libraries) {
    return libraries.filter(library => {
        if ((0, exports.isLibraryTopology)(library)) {
            return (0, validateLibraryURL_1.validateLibraryURL)(library.url);
        } else {
            return (0, validateLibraryURL_1.validateLibraryURL)(library.baseURL);
        }
    });
}

function createRegistry({
    host
}) {
    return async (params) => {
        const options = withDefaultOptions(params.options || {});
        const resourceLoader = (0, createResourceLoader_1.createResourceLoader)({
            options,
            fetcher: params.fetcher,
            globals: params.globals,
        });
        const {
            libraries,
            registryOverrideLibrary
        } = splitLibraries(filterUntrustedURLs(params.libraries));
        if (registryOverrideLibrary) {
            const registry = await (0, loadExternalRegistry_1.loadExternalRegistry)({
                resourceLoader,
                host,
                url: registryOverrideLibrary.url,
            });
            return registry(Object.assign(Object.assign({}, params), {
                libraries
            }));
        }
        const context = await loadContext({
            host,
            libraries,
            resourceLoader,
            options,
        });
        let loaders = {};
        const librariesComponents = {};
        async function createComponentLoaders(manifests) {
            const tasks = manifests.map(async ({
                order,
                manifest
            }) => {
                const loadBundle = resourceLoader.createBundleLoader({
                    environment: manifest.getEnvironment(),
                });
                // without *.local
                const namespace = (0, editor_elements_conventions_1.withProdNamespace)(manifest.getNamespace());
                const mode = (params.modes && params.modes[namespace]) || params.mode || 'lazy';
                librariesComponents[order] =
                    mode === 'lazy' ?
                    (0, createComponentLoaders_1.createLazyComponentLoaders)({
                        manifest,
                        loadBundle,
                    }) :
                    await (0, createComponentLoaders_1.createEagerComponentLoaders)({
                        manifest,
                        loadBundle,
                    });
            });
            await Promise.all(tasks);
            loaders = {};
            Object.keys(librariesComponents)
                .map(v => parseInt(v, 10))
                .sort()
                .forEach(index => {
                    Object.assign(loaders, librariesComponents[index]);
                });
        }
        if (!options.useLazyLoadersInit) {
            await createComponentLoaders(context.manifests);
        }
        const loadComponents = async (componentNames) => {
            const pending = componentNames.map(async (componentName) => {
                return {
                    componentName,
                    model: await loaders[componentName](),
                };
            });
            const models = await Promise.all(pending);
            return models.reduce((acc, {
                model,
                componentName
            }) => {
                acc[componentName] = model;
                return acc;
            }, {});
        };
        let isContextFulfilled = false;
        let areComponentsLoadersCreated = !options.useLazyLoadersInit;
        const pendingPromises = {};
        return {
            getComponentsLoaders() {
                return loaders;
            },
            getManifestURLs() {
                return [...context.urls];
            },
            getHostBundleAssets() {
                return (0, utils_1.flat)(context.manifests.map(({
                    manifest
                }) => {
                    const model = manifest.getHostBundleModel();
                    return (0, createComponentLoaders_1.getComponentAssets)({
                        resource: model
                    });
                }));
            },
            async loadComponents(componentNames) {
                return loadComponents(componentNames);
            },
            loadAllComponents() {
                const componentNames = Object.keys(loaders);
                return loadComponents(componentNames);
            },
            getLibrariesAssets() {
                return (0, utils_1.flat)(context.manifests.map(({
                    manifest
                }) => manifest.getLibraryAssets()));
            },
            getRuntime() {
                const _libraries = [
                    ...context.manifests.map(({
                        manifest
                    }) => manifest.getManifest()),
                ];
                if (registryOverrideLibrary) {
                    _libraries.push(registryOverrideLibrary);
                }
                return {
                    libraries: _libraries,
                };
            },
            async ensureComponentLoadersAreCreated() {
                if (!areComponentsLoadersCreated) {
                    if (!pendingPromises.componentsLoaders) {
                        pendingPromises.componentsLoaders = createComponentLoaders(context.manifests);
                    }
                    await pendingPromises.componentsLoaders;
                    areComponentsLoadersCreated = true;
                    pendingPromises.componentsLoaders = null;
                }
            },
            async ensureManifestsAreLoaded() {
                if (!isContextFulfilled && context.loadManifests) {
                    if (!pendingPromises.librariesManifests) {
                        pendingPromises.librariesManifests = new Promise(async (resolve) => {
                            const manifests = await context.loadManifests();
                            await createComponentLoaders(manifests);
                            resolve();
                        });
                    }
                    await pendingPromises.librariesManifests;
                    isContextFulfilled = true;
                    pendingPromises.librariesManifests = null;
                }
            },
        };
    };
}
exports.createRegistry = createRegistry;
//# sourceMappingURL=createRegistry.js.map