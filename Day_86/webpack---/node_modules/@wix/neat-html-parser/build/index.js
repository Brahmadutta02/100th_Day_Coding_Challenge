'use strict';

var _require = require('./tokens'),
    OPEN_TAG_START = _require.OPEN_TAG_START,
    TAG_END = _require.TAG_END,
    SELF_CLOSING = _require.SELF_CLOSING,
    CLOSING_TAG_START = _require.CLOSING_TAG_START,
    HTML_END = _require.HTML_END,
    SPACE = _require.SPACE;

var selfClosingTags = require('./selfClosingTags');

var selfClosingTagsSet = new Set(selfClosingTags);
var bracketsSet = new Set([OPEN_TAG_START, TAG_END, SELF_CLOSING, CLOSING_TAG_START]);

function parseTagName(html, lastBracketTokenEnd, currentTokenIndex, indexOfFirstSpaceAfterOpenBracket) {
    var indexOfTagNameEnd = indexOfFirstSpaceAfterOpenBracket || currentTokenIndex;
    return html.slice(lastBracketTokenEnd + 1, indexOfTagNameEnd).toLowerCase();
}

function parseProps(html, lastBracketTokenEnd, currentTokenIndex, indexOfFirstSpaceAfterOpenBracket) {
    var indexOfTagNameEnd = indexOfFirstSpaceAfterOpenBracket || currentTokenIndex;
    return html.slice(indexOfTagNameEnd + 1, currentTokenIndex);
}

function processTagEnd(html, lastBracketToken, lastBracketTokenEnd, currentTokenIndex, indexOfFirstSpaceAfterOpenBracket, callbacks) {
    var tagName = parseTagName(html, lastBracketTokenEnd, currentTokenIndex, indexOfFirstSpaceAfterOpenBracket);

    if (lastBracketToken === OPEN_TAG_START) {
        var props = parseProps(html, lastBracketTokenEnd, currentTokenIndex, indexOfFirstSpaceAfterOpenBracket);
        if (selfClosingTagsSet.has(tagName)) {
            callbacks.onSelfClosingTag && callbacks.onSelfClosingTag({
                tagName: tagName,
                props: props
            });
        } else {
            callbacks.onOpenTag && callbacks.onOpenTag({
                tagName: tagName,
                props: props
            });
        }
    } else {
        callbacks.onClosingTag && callbacks.onClosingTag({
            tagName: tagName,
            props: ''
        });
    }
}

function detectToken(html, i) {
    var currentTokenStart = i;
    var currentToken = void 0;

    switch (html[i]) {
        case '<':
            if (html[i + 1] === '/') {
                currentToken = CLOSING_TAG_START;
                i++;
                break;
            }
            currentToken = OPEN_TAG_START;
            break;
        case '>':
            currentToken = TAG_END;
            break;
        case '/':
            if (html[i + 1] === '>') {
                currentToken = SELF_CLOSING;
                i++;
                break;
            }
        case ' ':
            currentToken = SPACE;
            break;
        default:
            currentToken = html[i];
    }

    if (i === html.length) {
        currentToken = HTML_END;
    }

    return currentToken;
}

function parseFragment(html) {
    var callbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var currentToken = void 0;
    var currentTokenStart = void 0;
    var currentTokenEnd = void 0;

    var lastBracketToken = void 0;
    var lastBracketTokenStart = void 0;
    var lastBracketTokenEnd = void 0;

    var indexOfFirstSpaceAfterOpenBracket = void 0;
    var htmlLength = html.length;
    var i = 0;

    while (i <= htmlLength) {
        //detect token at current token and move pointer to the end of the token
        currentTokenStart = i;
        currentToken = detectToken(html, i);
        i = currentTokenEnd = currentTokenStart + currentToken.length - 1;

        switch (currentToken) {
            case OPEN_TAG_START:
            case CLOSING_TAG_START:
                {
                    var text = html.slice(lastBracketTokenEnd + 1, currentTokenStart);

                    if (text && callbacks.onText) {
                        callbacks.onText(text);
                    }

                    indexOfFirstSpaceAfterOpenBracket = null;
                    break;
                }

            case TAG_END:
                processTagEnd(html, lastBracketToken, lastBracketTokenEnd, i, indexOfFirstSpaceAfterOpenBracket, callbacks);
                break;

            case SELF_CLOSING:
                {
                    if (!callbacks.onSelfClosingTag) {
                        break;
                    }

                    callbacks.onSelfClosingTag({
                        tagName: parseTagName(html, lastBracketTokenEnd, currentTokenStart, indexOfFirstSpaceAfterOpenBracket),
                        props: parseProps(html, lastBracketTokenEnd, currentTokenStart, indexOfFirstSpaceAfterOpenBracket)
                    });
                    break;
                }

            case SPACE:
                if (!indexOfFirstSpaceAfterOpenBracket && (lastBracketToken === OPEN_TAG_START || lastBracketToken === CLOSING_TAG_START)) {
                    indexOfFirstSpaceAfterOpenBracket = i;
                }
                break;

            case HTML_END:
                if (!callbacks.onText) break;

                if (!lastBracketToken) {
                    //all html is text
                    callbacks.onText(html);
                    return;
                }

                //text after last tag
                if (lastBracketTokenEnd !== htmlLength - 1) {
                    callbacks.onText(html.slice(lastBracketTokenEnd + 1, htmlLength));
                }
                break;
        }

        //if current token is bracket save it to lastBrackToken
        if (bracketsSet.has(currentToken)) {
            lastBracketToken = currentToken;
            lastBracketTokenEnd = currentTokenEnd;
            lastBracketTokenStart = currentTokenStart;
        }

        i++;
    }
}

module.exports = {
    parseFragment: parseFragment
};