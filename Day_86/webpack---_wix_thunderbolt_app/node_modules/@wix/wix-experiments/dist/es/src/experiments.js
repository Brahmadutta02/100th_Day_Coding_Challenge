import {
    __assign,
    __extends
} from "tslib";
import {
    baseUrl
} from './base-url';
import {
    getGlobalDefaults
} from './conduction-utils/global-defaults';
import {
    getGlobalRequestContext
} from './conduction-utils/global-defaults-checks';
import {
    getRequestContextQuery
} from './conduction-utils/request-context';
import {
    getCacheInstance
} from './experiments-cache';
import {
    tryParse
} from './experiments-data-utils';
import {
    httpRequest
} from './http-request';
import {
    getAllInScopePath,
    getExperimentPath
} from './urlMap';
import {
    ReadOnlyExperiments
} from './ReadOnlyExperiments';
var noop = function() {
    /* */
};
var Experiments = /** @class */ (function(_super) {
    __extends(Experiments, _super);

    function Experiments(obj) {
        if (obj === void 0) {
            obj = {};
        }
        var _this = _super.call(this, obj) || this;
        var globalDefaults = getGlobalDefaults();
        _this.useNewApi =
            typeof obj.useNewApi !== 'undefined' ?
            obj.useNewApi :
            globalDefaults.useNewApi || false;
        _this.experiments = obj.experiments || {};
        _this.loaders = new Map();
        _this.baseUrl = baseUrl(_this.useNewApi, obj.baseUrl);
        _this.requestContext =
            obj.requestContext || getGlobalRequestContext(globalDefaults);
        _this.onError = obj.onError || noop;
        if (obj.scope) {
            _this.load(obj.scope);
        }
        if (obj.scopes) {
            obj.scopes.forEach(_this.load.bind(_this));
        }
        return _this;
    }
    Experiments.prototype.add = function(obj) {
        this.experiments = __assign(__assign({}, this.experiments), obj);
    };
    Experiments.prototype._addLoader = function(url, promise) {
        var _this = this;
        this.loaders.set(url, promise);
        promise.then(function() {
            _this.loaders.delete(url);
        });
        return promise;
    };
    Experiments.prototype._getUrlWithFallback = function(url, fallback) {
        var _this = this;
        var cachedResponse = getCacheInstance().getUrlResponse(url);
        if (cachedResponse !== undefined) {
            return Promise.resolve(cachedResponse);
        }
        var cachedRequest = getCacheInstance().getUrlRequest(url);
        if (cachedRequest !== undefined) {
            return cachedRequest;
        }
        var existingRequest = this.loaders.get(url);
        if (existingRequest !== undefined) {
            return existingRequest;
        }
        var requestPromise = httpRequest(url);
        getCacheInstance().addUrlRequest(url, requestPromise);
        return requestPromise.catch(function(error) {
            _this.onError(error);
            return fallback;
        });
    };
    Experiments.prototype.load = function(scope) {
        var _this = this;
        var scopeConductionPath = getAllInScopePath(scope, this.useNewApi);
        var requestContextQuery = this.useNewApi ?
            getRequestContextQuery(this.requestContext) :
            '';
        var url = "" + this.baseUrl + scopeConductionPath + requestContextQuery;
        var result = this._getUrlWithFallback(url, '{}')
            .then(function(response) {
                return tryParse(response);
            })
            .then(function(response) {
                return (_this.useNewApi ? response.values : response);
            })
            .then(function(obj) {
                _this.add(obj);
                return obj;
            });
        // @ts-ignore
        return this._addLoader(url, result);
    };
    Experiments.prototype.conduct = function(spec, fallbackValue) {
        var _this = this;
        // check if a spec value was already loaded to the cache indirectly through another request
        var cachedResponse = getCacheInstance().getExperimentValue(spec, this.useNewApi);
        if (cachedResponse !== undefined) {
            return this._addConductResult(spec, cachedResponse);
        }
        var experimentsPath = getExperimentPath(spec, fallbackValue, this.useNewApi);
        var requestContextQuery = this.useNewApi ?
            getRequestContextQuery(this.requestContext) :
            '';
        var url = "" + this.baseUrl + experimentsPath + requestContextQuery;
        var result = this._getUrlWithFallback(url, fallbackValue !== null && fallbackValue !== void 0 ? fallbackValue : '').then(function(response) {
            return _this._addConductResult(spec, response);
        });
        return this._addLoader(url, result);
    };
    Experiments.prototype.pending = function() {
        return !!this.loaders.size;
    };
    Experiments.prototype.ready = function() {
        return Promise.all(Array.from(this.loaders.values()));
    };
    Experiments.prototype._addConductResult = function(spec, conductResponse) {
        var _a;
        var value = this.useNewApi ?
            JSON.parse(conductResponse).value :
            conductResponse;
        this.add((_a = {}, _a[spec] = value, _a));
        return Promise.resolve(value);
    };
    return Experiments;
}(ReadOnlyExperiments));
export {
    Experiments
};
//# sourceMappingURL=experiments.js.map