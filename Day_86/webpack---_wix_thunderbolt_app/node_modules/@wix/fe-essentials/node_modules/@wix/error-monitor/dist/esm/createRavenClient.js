import {
    sanitizeTags
} from './utils/addTags';
import {
    RavenToSentryAdapter
} from './utils/RavenToSentryAdapter';
import {
    InternalErrorMonitor
} from './InternalErrorMonitor';
import {
    createRavenToSentryTransportTestkitAdapter
} from './utils/createRavenToSentryTransportTestkitAdapter';
/**
 * Creates new Raven client, to be used inside Viewer
 *
 * @param options
 * @return ravenClient
 */
export function createRavenClient(options) {
    const {
        Raven,
        dsn,
        appName = '',
        version,
        tags,
        user,
        environment,
        beforeSend,
        transport,
    } = options;
    // Using "new Raven.Client()" to avoid altering the global Raven. See raven-js/src/singleton.js
    // @ts-expect-error
    const ravenClient = new Raven.Client();
    const sanitizedTags = tags ? sanitizeTags(tags, appName) : undefined;
    const release = version ? `${appName}@${version}` : undefined;
    const ravenOptions = Object.assign(Object.assign(Object.assign(Object.assign({}, (beforeSend && {
        dataCallback: beforeSend
    })), (environment && {
        environment
    })), (sanitizedTags && {
        tags: sanitizedTags
    })), (release && {
        release
    }));
    ravenClient.config(dsn, ravenOptions);
    if (user && user.id) {
        ravenClient.setUserContext(user);
    }
    // for testing purposes only
    if (transport) {
        const ravenTransportAdapter = createRavenToSentryTransportTestkitAdapter(transport);
        ravenClient.setTransport(ravenTransportAdapter);
    }
    const sentryCompatibleRaven = new RavenToSentryAdapter(ravenClient);
    // we use type casting here because we don't want Raven types to leak inside ErrorMonitor
    return new InternalErrorMonitor(sentryCompatibleRaven, options.appName);
}
//# sourceMappingURL=createRavenClient.js.map