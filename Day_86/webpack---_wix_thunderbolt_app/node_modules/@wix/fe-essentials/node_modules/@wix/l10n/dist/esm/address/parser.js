import {
    formats,
    defaultFormat
} from './formats';
const libaddressFields = {
    '%N': 'name',
    '%O': 'organization',
    '%A': 'addressLines',
    '%D': 'dependentLocality',
    '%C': 'locality',
    '%S': 'administrativeArea',
    '%Z': 'postalCode',
    '%X': 'sortingCode',
    '%R': 'postalCountry',
};
const streetNameFirstCountries = [
    'IE',
    'NL',
    'JP',
    'PL',
    'BR',
    'PT',
    'RU',
    'AU',
    'DE',
    'CH',
];
const convertStreetAddressToAddressLine = ({
    name,
    number
}, countryCode) => {
    if (!name && !number) {
        return '';
    }
    if (!name || !number) {
        return name || number;
    }
    let first = number;
    let second = name;
    if (streetNameFirstCountries.includes(countryCode)) {
        first = name;
        second = number;
    }
    return `${first} ${second}`.trim();
};
export const convertWixAdressToGoogleAddress = (address, addressContactDetails) => {
    const addressLines = [];
    if (address.streetAddress) {
        const streetAddress = convertStreetAddressToAddressLine(address.streetAddress, address.country);
        addressLines.push(streetAddress);
    } else {
        if (address.addressLine) {
            addressLines.push(address.addressLine);
        }
        if (address.addressLine_2) {
            addressLines.push(address.addressLine_2);
        }
    }
    return {
        name: addressContactDetails === null || addressContactDetails === void 0 ? void 0 : addressContactDetails.fullName,
        organization: addressContactDetails === null || addressContactDetails === void 0 ? void 0 : addressContactDetails.company,
        postalCountry: address.country,
        administrativeArea: address.subdivision,
        locality: address.city,
        country: address.countryFullname,
        postalCode: address.postalCode,
        addressLines,
    };
};
export const getGoogleTemplate = (countryCode) => {
    const code = countryCode === null || countryCode === void 0 ? void 0 : countryCode.toUpperCase();
    if (code && code in formats) {
        return formats[code];
    }
    return defaultFormat;
};
export const isAddressFieldToken = (token) => {
    return token[0] === '%' && token !== '%n';
};
export const getTokenName = (token) => {
    return libaddressFields[token];
};
const hasFieldToken = (address, field) => {
    if (field === 'addressLines') {
        return (address.addressLines !== undefined && address.addressLines.length > 0);
    }
    return address[field] !== undefined && address[field] !== '';
};
/**
 * A function to parse a Google's open-source address metadata templates into tokens
 * @example
 * '%N%n%O%n%A%n%C, %S %Z' -> ['%N', '%n', '%O', '%n', '%A', '%n', '%C', ', ', '%S', ' ', '%Z']
 */
export const parseGoogleTemplate = (template) => {
    const parts = [];
    let i = 0;
    while (i < template.length) {
        if (template[i] === '%') {
            parts.push(template.slice(i, i + 2));
            i += 1;
        } else {
            let j = i;
            while (template[j] !== '%' && j < template.length) {
                j += 1;
            }
            parts.push(template.slice(i, j));
            i = j - 1;
        }
        i += 1;
    }
    return parts;
};
/**
 * A function to "trim" the template, ie to safely remove unused template fields.
 */
export const trimGoogleTemplate = (address, tokens) => {
    const parts = [];
    let i = 0;
    while (i < tokens.length) {
        const token = tokens[i];
        if (token === '%n') {
            parts.push(token);
        } else if (isAddressFieldToken(token)) {
            const tokenName = getTokenName(token);
            if (hasFieldToken(address, tokenName)) {
                parts.push(token);
            }
        } else {
            const notFollowingRemovedField = i === 0 ||
                !isAddressFieldToken(tokens[i - 1]) ||
                (parts.length > 0 && isAddressFieldToken(parts[parts.length - 1]));
            const notPrecedingEmptyField = i === token.length - 1 ||
                token[i + 1] === '%n' ||
                hasFieldToken(address, getTokenName(tokens[i + 1]));
            if (notFollowingRemovedField && notPrecedingEmptyField) {
                parts.push(token);
            }
        }
        i += 1;
    }
    return parts;
};
export const applyTemplate = (address, tokens, options) => {
    const lines = [];
    let line = '';
    for (const token of tokens) {
        if (token === '%n') {
            // Line break is inserted only in case the prvious line is not empty.
            if (line.length > 0) {
                lines.push(line);
                line = '';
            }
        } else if (!isAddressFieldToken(token)) {
            line += token;
        } else {
            const field = getTokenName(token);
            if (field === 'postalCountry') {
                continue;
            }
            if (field === 'addressLines') {
                if (address.addressLines && address.addressLines.length > 0) {
                    line += address.addressLines[0];
                    lines.push(line);
                    line = '';
                    if (address.addressLines.length === 2) {
                        lines.push(address.addressLines[1]);
                    }
                }
                continue;
            }
            line += address[field];
        }
    }
    if (line.length > 0) {
        lines.push(line);
    }
    if (options.appendCountry && address.country) {
        lines.push(address.country);
    }
    return lines;
};
//# sourceMappingURL=parser.js.map