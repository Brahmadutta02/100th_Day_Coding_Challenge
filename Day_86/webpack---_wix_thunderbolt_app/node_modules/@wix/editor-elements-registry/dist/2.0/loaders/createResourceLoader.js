"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createResourceLoader = exports.getScriptTag = void 0;
const utils_1 = require("../utils");
const evaluateBundle_1 = require("./evaluateBundle");
const loadAssets_1 = require("./loadAssets");
const RETRY_TIMES = 3;
/**
 * we need to pass hot bundle id for AMD cases
 * otherwise hot bundle will never be executed
 */
const HOT_BUNDLE_ID = 'hot';

function getScriptTag(url) {
    if (!(0, utils_1.isBrowserMainThread)()) {
        return null;
    }
    const element = document.querySelector(`script[src="${url}"]`);
    return element;
}
exports.getScriptTag = getScriptTag;

function createPromiseGuard() {
    const requests = new Map();
    return async (id, {
        factory,
        persistent = true,
    }) => {
        if (requests.has(id)) {
            return requests.get(id);
        }
        const pending = factory();
        requests.set(id, pending);
        try {
            const model = await pending;
            if (!persistent) {
                requests.delete(id);
            }
            return model;
        } catch (e) {
            if (requests.has(id)) {
                requests.delete(id);
            }
            throw e;
        }
    };
}

function withRetry({
    times,
    task,
}) {
    let counter = 0;
    return new Promise((resolve, reject) => {
        const run = async () => {
            try {
                const response = await task();
                resolve(response);
            } catch (e) {
                counter++;
                if (counter >= times) {
                    reject(e);
                } else {
                    run();
                }
            }
        };
        run();
    });
}
const _fetcher = async (url) => {
    const response = await fetch(url);
    return response.text();
};

function createResourceLoader({
    options,
    globals,
    fetcher = _fetcher,
}) {
    const contexts = {};
    const loadResource = ({
        id,
        url
    }) => withRetry({
        times: RETRY_TIMES,
        task: async () => {
            if (options && options.useScriptsInsteadOfEval && (0, utils_1.isBrowser)()) {
                const script = document.createElement('script');
                script.src = url;
                try {
                    const pending = new Promise((resolve, reject) => {
                        script.addEventListener('load', () => resolve());
                        script.addEventListener('error', () => reject());
                    });
                    document.head.appendChild(script);
                    await pending;
                } catch (e) {
                    script.remove();
                    throw e;
                }
            } else {
                const bundle = await fetcher(url);
                (0, evaluateBundle_1.evaluateBundle)(bundle, {
                    id,
                    globals,
                    contexts,
                    useExperimentalEval: options && options.useExperimentalEval,
                });
            }
        },
    });
    const getModelByBundleID = (id) => {
        if ((0, utils_1.isServer)() && (0, evaluateBundle_1.isOriginalRequireFunctionAvailable)()) {
            return (0, evaluateBundle_1.getModelFromContext)(id, contexts[id]);
        } else {
            return (0, evaluateBundle_1.getModel)(id);
        }
    };
    return {
        async fetch({
            url
        }) {
            return fetcher(url);
        },
        async fetchLibraryManifest({
            url
        }) {
            const response = await fetcher(url);
            return JSON.parse(response);
        },
        createBundleLoader({
            environment
        }) {
            const guard = createPromiseGuard();
            let pendingEnvironmentPromise = null;
            const fetchEnvironment = async () => {
                if (pendingEnvironmentPromise) {
                    return pendingEnvironmentPromise;
                }
                const load = ({
                    id,
                    url
                }) => {
                    if (!url) {
                        return;
                    }
                    const element = getScriptTag(url);
                    if (element) {
                        return Promise.resolve();
                    }
                    return loadResource({
                        id,
                        url,
                    });
                };
                pendingEnvironmentPromise = Promise.all([
                    load({
                        url: environment.runtime
                    }),
                    (0, utils_1.isBrowser)() ?
                    load({
                        id: HOT_BUNDLE_ID,
                        url: environment.hot
                    }) :
                    null,
                ]).then(() =>
                    /**
                     * Trigger hot bundle for requirejs env.
                     * otherwise – hot bundle will be loaded but never initialized
                     **/
                    getModelByBundleID(HOT_BUNDLE_ID));
                return pendingEnvironmentPromise;
            };
            return async ({
                url,
                id,
                assets = []
            }) => {
                /**
                 * `loadingAssetsPromise` – not sure we should wait until CSS is loaded,
                 * since it may cause waterfall
                 */
                if (assets) {
                    (0, loadAssets_1.loadAssets)(assets.filter(a => !!a));
                }
                if (id && ((0, utils_1.isBrowser)() || (0, utils_1.isWorker)())) {
                    const model = await (0, evaluateBundle_1.getModel)(id);
                    if (model) {
                        return model;
                    }
                }
                await (url ?
                    guard(url, {
                        persistent: !utils_1.LOCAL_DEV_HOSTS.some(host => url.startsWith(host)),
                        factory: async () => {
                            if (environment) {
                                await fetchEnvironment();
                            }
                            return loadResource({
                                id,
                                url,
                            });
                        },
                    }) :
                    null);
                if (!id) {
                    return null;
                }
                return getModelByBundleID(id);
            };
        },
    };
}
exports.createResourceLoader = createResourceLoader;
//# sourceMappingURL=createResourceLoader.js.map