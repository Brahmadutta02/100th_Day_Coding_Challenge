"use strict";
(self.webpackJsonp__wix_thunderbolt_app = self.webpackJsonp__wix_thunderbolt_app || []).push([
    [5918], {
        7753: function(t, n, e) {
            e.r(n), e.d(n, {
                ScreenInAPISymbol: function() {
                    return p.JC
                },
                page: function() {
                    return I
                }
            });
            var i = e(61049),
                s = e(63788),
                o = e(5096),
                a = e(32979),
                r = e(43757),
                c = e(11717),
                d = e(31191);
            const l = t => `${t}-screenIn`;
            class m {
                constructor(t) {
                    this.animator = t, this.definitions = {}, this.sessionState = {
                        played: new Map,
                        running: new Map
                    }
                }
                _shouldSkipPlayedAnimation(t) {
                    const n = this.sessionState.played.has(t),
                        {
                            playOnce: e,
                            persistOnNav: i
                        } = this.sessionState.played.get(t) || {};
                    return n && (e || i)
                }
                _hideComponent(t) {
                    const n = document.querySelector(`#${t}`);
                    n && (n.style.opacity = 0)
                }
                unhideComponent(t) {
                    const n = document.querySelector(`#${t}`);
                    n && (n.dataset.screenInHide = "done", n.style.opacity = "", n.style.visibility = "inherit")
                }
                _addAnimatingClass(t) {
                    const n = document.getElementById(t);
                    n && (n.classList.add("is-animating"), n.dataset.screenInHide = "done")
                }
                _removeAnimatingClass(t) {
                    const n = document.getElementById(t);
                    n && (n.classList.remove("is-animating"), n.dataset.screenInHide = "done")
                }
                updateDefinitions(t) {
                    this.definitions = Object.assign(Object.assign({}, this.definitions), t)
                }
                _hideCompBeforeAnimation(t) {
                    const n = l(t);
                    this._shouldSkipPlayedAnimation(n) ? this.unhideComponent(t) : this._hideComponent(t)
                }
                hideBeforeAnimation(t) {
                    this.getCompsToHide(t).forEach((({
                        compId: t
                    }) => {
                        this._hideCompBeforeAnimation(t)
                    }))
                }
                handleRotation(t, n) {
                    t.setAttribute("data-angle", String(n)), t.setAttribute("data-angle-style-location", "style")
                }
                trigger(t = []) {
                    t.reduce(((t, {
                        compId: n
                    }) => {
                        const e = this.definitions[n] || [];
                        return t.concat(e)
                    }), []).forEach((t => {
                        var {
                            action: n
                        } = t, e = (0, d._T)(t, ["action"]);
                        return this.executeAnimation(n, e)
                    }))
                }
                init(t) {
                    this.updateDefinitions(t), this.stopAnimations(), this.hideBeforeAnimation(t)
                }
                addDefinition(t, n, e) {
                    this.handleRotation(n, e), this.updateDefinitions(t)
                }
                executeAnimation(t, {
                    name: n,
                    targetId: e,
                    duration: i = 0,
                    delay: s = 0,
                    playOnce: o = !1,
                    persistOnNav: a = !1,
                    params: r = {}
                }) {
                    const c = l(e);
                    if (this._shouldSkipPlayedAnimation(c)) return void this.unhideComponent(e);
                    const d = {
                            name: n,
                            targetId: e,
                            duration: i,
                            delay: s,
                            params: r
                        },
                        m = {
                            name: "BaseClear",
                            targetId: e,
                            duration: 0,
                            delay: 0,
                            params: {
                                props: "clip,clipPath,webkitClipPath,willChange,opacity,transform,transformOrigin",
                                immediateRender: !1
                            }
                        };
                    this.animator.runSequence([{
                        type: "Animation",
                        data: d
                    }, {
                        type: "Animation",
                        data: m
                    }], {
                        callbacks: {
                            onStart: n => {
                                this._addAnimatingClass(e), this.sessionState.running.set(n, {
                                    targetId: e,
                                    action: t
                                })
                            },
                            onComplete: t => {
                                this._removeAnimatingClass(e), this.sessionState.running.delete(t)
                            },
                            onInterrupt: t => {
                                this._removeAnimatingClass(e), this.sessionState.running.delete(t)
                            }
                        }
                    }), this.sessionState.played.set(c, {
                        playOnce: o,
                        persistOnNav: a
                    })
                }
                stopAnimations({
                    skipPersistent: t = !0
                } = {}) {
                    this.sessionState.running.forEach((({
                        targetId: n
                    }, e) => {
                        const i = l(n);
                        t && this.sessionState.played.get(i).persistOnNav || this.animator.kill(e, 1)
                    }))
                }
                getAnimationProperties(t) {
                    return this.animator.getAnimationProperties(t)
                }
                getCompsToHide(t) {
                    return Object.entries(t).reduce(((t, [n, e]) => (e.some((({
                        name: t
                    }) => {
                        const n = this.animator.getAnimationProperties(t);
                        return n && n.hideOnStart
                    })) && t.push({
                        compId: n
                    }), t)), [])
                }
                clearState() {
                    this.sessionState.played.clear(), this.sessionState.running.clear()
                }
            }
            var p = e(18562);

            function u({
                manager: t
            }) {
                const n = {};

                function e(n) {
                    const e = n.filter((t => t.visible)).map((t => ({
                        compId: t.id,
                        action: "screenIn"
                    })));
                    t.trigger(e)
                }

                function i(t, i) {
                    const s = n[i] || function(t, n) {
                        const e = {
                            root: null,
                            rootMargin: "0px",
                            threshold: [n]
                        };
                        return new window.IntersectionObserver((function(n, e) {
                            const i = n.map((t => ({
                                visible: t.isIntersecting,
                                ratio: t.intersectionRatio,
                                rect: t.intersectionRect,
                                id: t.target.id
                            })));
                            n.forEach((t => t.isIntersecting && e.unobserve(t.target))), t(i)
                        }), e)
                    }(e, i);
                    s.observe(t), n[i] || (n[i] = s)
                }
                return {
                    start: function(n, e, s) {
                        const o = window.innerHeight;
                        if (e) {
                            const n = e.offsetHeight > o ? .01 : function(t, n) {
                                return t.getAnimationProperties(n).viewportThreshold
                            }(t, s) || 0;
                            i(e, n)
                        }
                    }
                }
            }
            var h = e(8562);
            const g = (0, r.ff)([(0, r.t6)(i.$e, p.u2), (0, r.t6)(i.Wf, p.u2), s.m, o.ZQ, a.C, (0, r.jt)(c.FK)], ((t, n, e, i, s, o) => () => {
                    const {
                        compIdToActions: a,
                        compIdToRotations: r
                    } = t;
                    if (e && !(0, h.yF)(i)) return void Object.keys(a).forEach((async t => {
                        await s.waitForComponentToRender(t), m.prototype.unhideComponent(t)
                    }));
                    if (!o) return;
                    const c = o.getInstance().then((t => {
                        var e, i;
                        const s = null !== (i = null === (e = n.get()) || void 0 === e ? void 0 : e.screenInManager) && void 0 !== i ? i : new m(t);
                        s.init(a);
                        const o = u({
                            manager: s
                        });
                        return n.update((t => Object.assign(Object.assign({}, t), {
                            screenInManager: s,
                            viewport: o
                        }))), {
                            animations: o,
                            screenInManager: s
                        }
                    }));
                    return async (t, n, i) => {
                        if (!i) return;
                        const {
                            animations: s,
                            screenInManager: o
                        } = await c;
                        if (e) return void o.unhideComponent(t);
                        let d = a[t];
                        if (n !== t) {
                            const t = JSON.parse(JSON.stringify(d));
                            t[0].targetId = n, d = t
                        }
                        o.addDefinition({
                            [n]: d
                        }, i, r[t]), s.start(n, i, d[0].name)
                    }
                })),
                f = (0, r.ff)([(0, r.t6)(i.$e, p.u2), p.cL, a.C, s.m], ((t, n, e) => {
                    let i = () => {};
                    return {
                        name: "screenInInit",
                        pageWillMount() {
                            const s = n();
                            if (!s) return;
                            const o = Object.keys(t.compIdToActions || {});
                            i = e.registerToCompLifeCycle(o, p.IA, s)
                        },
                        pageWillUnmount() {
                            i()
                        }
                    }
                }));
            var y = e(59032);
            const I = t => {
                t(p.cL).to(g), t(y.j.PageWillMountHandler, y.j.PageWillUnmountHandler).to(f)
            }
        }
    }
]);
//# sourceMappingURL=https://static.parastorage.com/services/wix-thunderbolt/dist/group_25.2c9c6bbf.chunk.min.js.map