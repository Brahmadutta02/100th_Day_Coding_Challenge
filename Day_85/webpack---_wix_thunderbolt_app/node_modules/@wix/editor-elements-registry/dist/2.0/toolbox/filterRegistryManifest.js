"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.filterRuntime = exports.filterRegistryManifest = void 0;
const utils_1 = require("../utils");
const NOT_USED_SHARED_URL_EMPTY_SYMBOL = '-';

function filterStatics(statics, componentNames) {
    if (!statics) {
        return null;
    }
    return Object.keys(statics)
        .filter(componentName => componentNames.includes(componentName))
        .reduce((acc, componentName) => {
            return Object.assign(Object.assign({}, acc), {
                [componentName]: statics[componentName]
            });
        }, {});
}

function filterParts(parts, componentNames) {
    const deps = [];
    if (!parts) {
        return {
            parts: null,
            deps: [],
        };
    }
    const filtered = Object.keys(parts)
        .filter(componentName => componentNames.includes(componentName))
        .reduce((acc, componentName) => {
            /**
             * Commented since manifest parts don't support shared bundles feature
             */
            // Object.keys(parts[componentName]).forEach(part => {
            //   const urls = parts[componentName][part];
            //   deps.push(
            //     ...(flat(
            //       urls.filter(indexes => Array.isArray(indexes)),
            //     ) as Array<number>),
            //   );
            // });
            return Object.assign(Object.assign({}, acc), {
                [componentName]: parts[componentName]
            });
        }, {});
    return {
        parts: filtered,
        deps,
    };
}

function filterComponents(components, componentNames) {
    if (!components) {
        return {
            components: null,
            deps: [],
        };
    }
    const deps = [];
    const filtered = Object.keys(components).reduce((acc, componentType) => {
        if (componentNames.includes(componentType)) {
            deps.push(...(0, utils_1.flat)(components[componentType].filter(indexes => Array.isArray(indexes))));
            return Object.assign(Object.assign({}, acc), {
                [componentType]: components[componentType]
            });
        }
        return acc;
    }, {});
    return {
        components: filtered,
        deps,
    };
}

function filterBatches(batches, componentNames) {
    if (!batches) {
        return {
            batches: null,
            deps: [],
        };
    }
    const deps = [];
    const filtered = Object.keys(batches).reduce((acc, batchName) => {
        const batch = batches[batchName];
        const batchComponents = batch.components ?
            batch.components.filter(component => componentNames.includes(component)) :
            [];
        const batchParts = batch.parts ?
            batch.parts.filter(([_, ...partComponents]) => {
                return partComponents.some(component => componentNames.includes(component));
            }) :
            [];
        if (batchComponents.length || (batchParts === null || batchParts === void 0 ? void 0 : batchParts.length)) {
            deps.push(...(0, utils_1.flat)(batch.url.filter(indexes => Array.isArray(indexes))));
            return Object.assign(Object.assign({}, acc), {
                [batchName]: Object.assign(Object.assign({}, batch), {
                    components: batchComponents,
                    parts: batchParts
                })
            });
        }
        return acc;
    }, {});
    return {
        batches: filtered,
        deps,
    };
}

function filterRegistryManifest(manifest, componentNames) {
    const {
        components,
        deps: componentDeps
    } = filterComponents(manifest.components, componentNames);
    const {
        batches,
        deps: batchesDeps
    } = filterBatches(manifest.batches, componentNames);
    const {
        parts,
        deps: partsDeps
    } = filterParts(manifest.parts, componentNames);
    const statics = filterStatics(manifest.statics, componentNames);
    const deps = [...componentDeps, ...batchesDeps, ...partsDeps];
    const shared = manifest.shared ?
        manifest.shared.map((url, index) => {
            return deps.includes(index) ? url : NOT_USED_SHARED_URL_EMPTY_SYMBOL;
        }) :
        [];
    return Object.assign(Object.assign({}, manifest), {
        components: components ? components : {},
        batches: batches ? batches : {},
        statics: statics ? statics : {},
        parts: parts ? parts : {},
        shared: shared.every(url => url === NOT_USED_SHARED_URL_EMPTY_SYMBOL) ?
            [] :
            shared
    });
}
exports.filterRegistryManifest = filterRegistryManifest;

function filterRuntime(runtime, usedComponents) {
    if (!runtime) {
        return null;
    }
    return {
        libraries: runtime.libraries.map(manifest => filterRegistryManifest(manifest, usedComponents)),
    };
}
exports.filterRuntime = filterRuntime;
//# sourceMappingURL=filterRegistryManifest.js.map