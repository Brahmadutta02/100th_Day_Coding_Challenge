'use strict';

var _createClass = function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();

var _slicedToArray = function() {
    function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;
        try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally {
            try {
                if (!_n && _i["return"]) _i["return"]();
            } finally {
                if (_d) throw _e;
            }
        }
        return _arr;
    }
    return function(arr, i) {
        if (Array.isArray(arr)) {
            return arr;
        } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
        } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
    };
}();

var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
};

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var debounce = require('./debounce');
var throttle = require('./throttle');

var createEvent = function createEvent(event, context, startTime) {
    return {
        dt: Date.now() - startTime,
        f: event,
        context: context
    };
};

var createBatch = function createBatch(events, startTime) {
    return {
        dt: Date.now() - startTime,
        e: events,
        g: {}
    };
};

var optimizeBatch = function optimizeBatch(batch) {
    var fieldCounts = {};
    var batchLen = batch.e.length;

    var events = batch.e.map(function(event) {
        var fields = Object.keys(event.f).map(function(field) {
            var value = event.f[field];
            var key = field + '|' + value;
            fieldCounts[key] = fieldCounts[key] || 0;
            fieldCounts[key]++;
            return [field, value, key];
        });

        return _extends({}, event, {
            f: fields
        });
    });

    var globalFields = {};
    events = events.map(function(event) {
        var fields = event.f.reduce(function(res, _ref) {
            var _ref2 = _slicedToArray(_ref, 3),
                field = _ref2[0],
                value = _ref2[1],
                key = _ref2[2];

            if (fieldCounts[key] === batchLen) {
                globalFields[field] = value;
            } else {
                res[field] = value;
            }

            return res;
        }, {});

        return _extends({}, event, {
            f: fields
        });
    });

    return _extends({}, batch, {
        e: events,
        g: globalFields
    });
};

var BatchQueue = function() {
    function BatchQueue() {
        _classCallCheck(this, BatchQueue);

        this._initilized = false;
    }

    _createClass(BatchQueue, [{
        key: '_reset',
        value: function _reset() {
            var _this = this;

            this._startTime = Date.now();
            this._resolve = null;
            this._promise = new Promise(function(resolve) {
                return _this._resolve = resolve;
            });
        }
    }, {
        key: 'init',
        value: function init(_ref3, flushHandler) {
            var _this2 = this;

            var delayMs = _ref3.delayMs,
                maxBatchSize = _ref3.maxBatchSize,
                useThrottle = _ref3.useThrottle,
                optimizeBatch = _ref3.optimizeBatch;

            if (this._initilized) {
                return;
            }

            this._maxBatchSize = maxBatchSize;
            this._optimizeBatch = optimizeBatch;
            this._queue = [];
            this._flushHandler = flushHandler;
            this._flushDebounced = useThrottle ? throttle(function() {
                return _this2.flush();
            }, delayMs) : debounce(function() {
                return _this2.flush();
            }, delayMs);
            this._initilized = true;

            this._reset();
        }
    }, {
        key: 'flush',
        value: function flush() {
            if (!this._queue.length) {
                return Promise.resolve();
            }

            var events = this._queue.splice(0, this._queue.length);
            var resolve = this._resolve;
            var startTime = this._startTime;

            this._reset();

            var batch = createBatch(events, startTime);

            if (this._optimizeBatch) {
                batch = optimizeBatch(batch);
            }

            return this._flushHandler(batch).then(resolve);
        }
    }, {
        key: 'feed',
        value: function feed(event, context) {
            this._queue.push(createEvent(event, context, this._startTime));

            if (this._queue.length === this._maxBatchSize) {
                return this.flush();
            }

            this._flushDebounced();

            return this._promise;
        }
    }]);

    return BatchQueue;
}();

module.exports = BatchQueue;
//# sourceMappingURL=batch-queue.js.map