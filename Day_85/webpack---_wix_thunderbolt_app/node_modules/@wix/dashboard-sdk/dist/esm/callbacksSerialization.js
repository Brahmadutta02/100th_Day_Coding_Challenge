import {
    __awaiter,
    __generator
} from "tslib";
import {
    proxy
} from 'comlink';
var proxyCallbackMarker = '__proxyCallbackId__wixSDK__';
var proxyPromiseMarker = '__proxyPromiseId__wixSDK__';
export var serializeAllMethodsIn = function(sdk) {
    return wrapMethodsWithProxy(sdk, function(originalMethod) {
        return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return __awaiter(void 0, void 0, void 0, function() {
                var _a, proxies, argsNoProxies, originalResult;
                return __generator(this, function(_b) {
                    switch (_b.label) {
                        case 0:
                            _a = extractProxies(args), proxies = _a[0], argsNoProxies = _a[1];
                            return [4 /*yield*/ , originalMethod(proxy(proxies), argsNoProxies)];
                        case 1:
                            originalResult = _b.sent();
                            return [2 /*return*/ , deserializeReturnValue(originalResult)];
                    }
                });
            });
        };
    });
};
export var deserializeAllMethodsIn = function(api) {
    return wrapMethodsWithProxy(api, function(originalMethod) {
        return function(proxies, args) {
            var argsWithProxies = insertProxies(proxies, args);
            var originalRun = originalMethod.apply(void 0, argsWithProxies);
            return serializeReturnValue(originalRun);
        };
    });
};
var serializeReturnValue = function(value) {
    return __awaiter(void 0, void 0, void 0, function() {
        var _a, proxies, clonables, _b;
        return __generator(this, function(_c) {
            switch (_c.label) {
                case 0:
                    _b = extractProxies;
                    return [4 /*yield*/ , value];
                case 1:
                    _a = _b.apply(void 0, [_c.sent()]), proxies = _a[0], clonables = _a[1];
                    return [2 /*return*/ , proxy({
                        proxies: proxies,
                        clonables: clonables
                    })];
            }
        });
    });
};
var deserializeReturnValue = function(value) {
    return __awaiter(void 0, void 0, void 0, function() {
        var _a, _b;
        return __generator(this, function(_c) {
            switch (_c.label) {
                case 0:
                    _a = insertProxies;
                    _b = [value === null || value === void 0 ? void 0 : value.proxies];
                    return [4 /*yield*/ , (value === null || value === void 0 ? void 0 : value.clonables)];
                case 1:
                    return [2 /*return*/ , _a.apply(void 0, _b.concat([_c.sent()]))];
            }
        });
    });
};
var extractProxies = function(data) {
    var walker = function(proxies, val) {
        var _a, _b;
        if (isPromise(val)) {
            var proxyId = uniqueId();
            proxies.promises[proxyId] = val;
            return _a = {}, _a[proxyPromiseMarker] = proxyId, _a;
        }
        if (isFunction(val)) {
            var proxyId = uniqueId();
            proxies.callbacks[proxyId] = function(innerProxies, argsAsArray) {
                var argsWithProxies = insertProxies(innerProxies, argsAsArray);
                var exec = val.apply(void 0, argsWithProxies);
                return serializeReturnValue(exec);
            };
            return _b = {}, _b[proxyCallbackMarker] = proxyId, _b;
        }
        if (Array.isArray(val)) {
            return val.map(function(i) {
                return walker(proxies, i);
            });
        }
        if (isObject(val)) {
            return mapObjectValues(val, function(i) {
                return walker(proxies, i);
            });
        }
        return val;
    };
    var proxies = {
        promises: {},
        callbacks: {}
    };
    var dataWithoutProxies = walker(proxies, data);
    return [proxies, dataWithoutProxies];
};
var insertProxies = function(proxies, data) {
    if (Array.isArray(data)) {
        return data.map(function(i) {
            return insertProxies(proxies, i);
        });
    }
    if (isObject(data) && data.hasOwnProperty(proxyPromiseMarker)) {
        var promiseId = data[proxyPromiseMarker];
        return proxies.promises[promiseId];
    }
    if (isObject(data) && data.hasOwnProperty(proxyCallbackMarker)) {
        var callbackId_1 = data[proxyCallbackMarker];
        // passing args in spread syntax to comlink proxy generates problem when transpiling to old JS version
        // so pass it as array and handle it on the deserialization level:
        return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return __awaiter(void 0, void 0, void 0, function() {
                var _a, innerProxies, argsNoProxies, exec;
                return __generator(this, function(_b) {
                    switch (_b.label) {
                        case 0:
                            _a = extractProxies(args), innerProxies = _a[0], argsNoProxies = _a[1];
                            return [4 /*yield*/ , proxies.callbacks[callbackId_1](proxy(innerProxies), argsNoProxies)];
                        case 1:
                            exec = _b.sent();
                            return [2 /*return*/ , deserializeReturnValue(exec)];
                    }
                });
            });
        };
    }
    if (isObject(data)) {
        return mapObjectValues(data, function(i) {
            return insertProxies(proxies, i);
        });
    }
    return data;
};
var wrapMethodsWithProxy = function(obj, callback) {
    return new Proxy(obj, {
        get: function(target, prop) {
            return callback(target[prop]);
        },
    });
};
var isPromise = function(val) {
    return val instanceof Promise;
};
var isObject = function(val) {
    return val && typeof val === 'object' && !isPromise(val);
};
var isFunction = function(val) {
    return typeof val === 'function';
};
var mapObjectValues = function(obj, callback) {
    var mapEntries = function(_a) {
        var key = _a[0],
            value = _a[1];
        return [key, callback(value)];
    };
    return Object.fromEntries(Object.entries(obj).map(mapEntries));
};
var uniqueId = (function() {
    var counter = 0;
    return function() {
        return ++counter;
    };
})();
//# sourceMappingURL=callbacksSerialization.js.map