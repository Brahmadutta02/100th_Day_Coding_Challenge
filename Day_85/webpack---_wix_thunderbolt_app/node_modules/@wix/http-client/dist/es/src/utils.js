import {
    __awaiter,
    __generator
} from "tslib";
import {
    isBrowser,
    isNode,
    isWebWorker
} from './env-util';
import {
    SSR_HOST,
    SSR_PROTOCOL
} from './constants';
export function isAbsoluteUrl(url) {
    if (typeof url !== 'string') {
        throw new TypeError("Expected a `string`, got `".concat(typeof url, "`"));
    }
    return /(^https?:)|(^\/\/)/.test(url);
}
export function silent(fn) {
    return __awaiter(this, void 0, void 0, function() {
        var _a;
        return __generator(this, function(_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    return [4 /*yield*/ , fn()];
                case 1:
                    _b.sent();
                    return [3 /*break*/ , 3];
                case 2:
                    _a = _b.sent();
                    return [3 /*break*/ , 3];
                case 3:
                    return [2 /*return*/ ];
            }
        });
    });
}
export function extractProp(data, path) {
    return path
        .split('.')
        .filter(function(prop) {
            return prop;
        })
        .reduce(function(result, prop) {
            return result[prop];
        }, data);
}
export function resolveHost(opts) {
    if (opts.baseURL) {
        return extractHost(opts.baseURL);
    } else if (opts.isSSR) {
        return SSR_HOST;
    } else if (typeof self !== 'undefined' && !!self.location) {
        return self.location.host;
    } else {
        return '';
    }
}
export function resolveProtocol(opts) {
    if (opts.baseURL) {
        return extractProtocol(opts.baseURL);
    } else if (opts.isSSR) {
        return SSR_PROTOCOL;
    } else if (typeof self !== 'undefined' && !!self.location) {
        return self.location.protocol;
    } else {
        return '';
    }
}
export function extractProtocol(url) {
    try {
        var asUrl = new URL(url);
        return asUrl.protocol;
    } catch (_a) {
        var hostAndProtocol = extractHostAndProtocolUsingRegExp(url);
        return hostAndProtocol.protocol;
    }
}
export function extractHost(url) {
    var asUrl;
    try {
        asUrl = new URL(url);
    } catch (_a) {
        // in case of PRURL
        asUrl = new URL("http:".concat(url));
    }
    try {
        return asUrl.host;
    } catch (_b) {
        var hostAndProtocol = extractHostAndProtocolUsingRegExp(url);
        return hostAndProtocol.host;
    }
}
/**
 * In mobile URL object doesnt implement host / protocol
 * This function will try to resolve the host/protocol using regular expression.
 */
function extractHostAndProtocolUsingRegExp(url) {
    var regExp = new RegExp('^(.*:)//([A-Za-z0-9-.]+)(:[0-9]+)?(.*)$');
    try {
        var urlOptions = regExp.exec(url);
        return {
            protocol: urlOptions[1],
            host: urlOptions[2]
        };
    } catch (_a) {
        return {
            protocol: 'http:',
            host: ''
        };
    }
}
export function changeHost(urlOrPath, host) {
    var url;
    try {
        url = new URL(urlOrPath);
        url.host = host;
        url.protocol = 'http';
    } catch (_a) {
        url = new URL("http://".concat(host));
        url.pathname = urlOrPath;
    }
    return url.toString();
}
export function getGlobalConfig() {
    var defaultConfig = {
        httpMockServer: {
            enabled: false
        }
    };
    var globalConfig;
    if (isNode() && process.env.HTTP_CLIENT_GLOBAL_CONFIG) {
        try {
            globalConfig = JSON.parse(process.env.HTTP_CLIENT_GLOBAL_CONFIG);
        } catch (e) {}
    }
    if (!globalConfig) {
        if (isBrowser()) {
            globalConfig = window._httpClientGlobalConfig;
        } else if (isWebWorker()) {
            // TODO
        }
    }
    return globalConfig || defaultConfig;
}
export function isHttpMockServerEnabled() {
    var globalConfig = getGlobalConfig();
    return globalConfig.httpMockServer.enabled;
}
export function shouldAllowUnmocked() {
    var globalConfig = getGlobalConfig();
    return globalConfig.httpMockServer.allowUnmocked;
}
export function toSearchQueryParams(params) {
    return Object.entries(params)
        .map(function(_a) {
            var key = _a[0],
                value = _a[1];
            return "".concat(key, "=").concat(encodeURIComponent(value));
        })
        .flat()
        .join('&');
}
//# sourceMappingURL=utils.js.map