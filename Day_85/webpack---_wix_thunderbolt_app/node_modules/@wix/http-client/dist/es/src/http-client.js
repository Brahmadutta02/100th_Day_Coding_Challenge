import {
    __assign,
    __awaiter,
    __generator,
    __spreadArray
} from "tslib";
import axios from 'axios';
import {
    buildAllHeaders,
    buildOptions,
    getUrlHeaders,
} from './options';
import {
    createHttpError
} from './error';
import {
    silent,
    isHttpMockServerEnabled,
    shouldAllowUnmocked,
    extractProp,
    resolveHost,
    getGlobalConfig,
    resolveProtocol,
} from './utils';
import {
    NO_SCENARIO_FOUND,
    SSR_HOST,
    SSR_PROTOCOL
} from './constants';
import {
    isNode
} from './env-util';
import {
    isWixDomain,
    requestIdOrEmptyString
} from './headers';
import xhrAdapter from 'axios/lib/adapters/xhr';
var HttpClient = /** @class */ (function() {
    function HttpClient(opts) {
        if (opts === void 0) {
            opts = {};
        }
        this.opts = opts;
        this.opts = defaultClientOptions(this.opts);
        this.client = axios.create(this.opts);
    }
    HttpClient.isHttpError = function(payload) {
        return !!(payload === null || payload === void 0 ? void 0 : payload.isWixHttpError);
    };
    HttpClient.prototype.request = function(requestOptionsOrFactory, overrides) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function() {
            var host, protocol, urlObject, requestOptions, signedInstance, headers, options;
            var _this = this;
            return __generator(this, function(_c) {
                host = resolveHost(this.opts);
                protocol = resolveProtocol(this.opts);
                urlObject = {
                    protocol: protocol,
                    host: host
                };
                requestOptions = typeof requestOptionsOrFactory === 'function' ?
                    requestOptionsOrFactory({
                        isSSR: this.opts.isSSR,
                        host: host
                    }) :
                    requestOptionsOrFactory;
                signedInstance = (overrides === null || overrides === void 0 ? void 0 : overrides.signedInstance) || ((_b = (_a = this.opts).getAppToken) === null || _b === void 0 ? void 0 : _b.call(_a)) || '';
                headers = this.getHeaders(requestOptions, signedInstance, urlObject);
                options = buildOptions({
                    requestOptions: requestOptions,
                    urlObject: urlObject,
                    headers: headers,
                    globalConfig: getGlobalConfig(),
                });
                if (this.opts.isSSR) {
                    options.baseURL = this.opts.baseURL ?
                        this.opts.baseURL :
                        "".concat(SSR_PROTOCOL, "://").concat(SSR_HOST);
                }
                return [2 /*return*/ , this.client
                    .request(options)
                    .catch(function(err) {
                        return _this.maybeFallbackRequest(err, requestOptions, urlObject, signedInstance);
                    })
                    .catch(function(err) {
                        return _this.handleRequestError(err, options);
                    })
                    .then(function(res) {
                        return _this.transformResponse(res, requestOptions);
                    })
                ];
            });
        });
    };
    HttpClient.prototype.get = function(url, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    method: 'GET'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.delete = function(url, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    method: 'DELETE'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.head = function(url, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    method: 'HEAD'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.options = function(url, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    method: 'OPTIONS'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.post = function(url, data, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    data: data,
                    method: 'POST'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.put = function(url, data, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    data: data,
                    method: 'PUT'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    HttpClient.prototype.patch = function(url, data, requestOptions) {
        return __awaiter(this, void 0, void 0, function() {
            var opts;
            return __generator(this, function(_a) {
                opts = __assign(__assign({}, requestOptions), {
                    url: url,
                    data: data,
                    method: 'PATCH'
                });
                return [2 /*return*/ , this.request(opts)];
            });
        });
    };
    Object.defineProperty(HttpClient.prototype, "CancelToken", {
        get: function() {
            return axios.CancelToken;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HttpClient.prototype, "isCancel", {
        get: function() {
            return axios.isCancel;
        },
        enumerable: false,
        configurable: true
    });
    HttpClient.prototype.getHeaders = function(requestOptions, signedInstance, urlObject) {
        if (typeof this.opts.createHeaders === 'function') {
            return this.getCustomHeaders(requestOptions, signedInstance, urlObject);
        }
        var wixHeadersOpts = {
            signedInstance: signedInstance,
            artifactId: this.opts.artifactId,
            csrf: false /* axios handles xsrf */ ,
            multilingualOptions: this.opts.multilingualOptions,
        };
        return buildAllHeaders(requestOptions, wixHeadersOpts, getGlobalConfig(), urlObject);
    };
    HttpClient.prototype.getCustomHeaders = function(requestOptions, signedInstance, urlObject) {
        var url = requestOptions.url;
        var authHeader = signedInstance && isWixDomain(url) ?
            {
                authorization: signedInstance
            } :
            {};
        var customHeaders = this.opts.createHeaders();
        var originalUrlHeader = getUrlHeaders(getGlobalConfig(), requestOptions, urlObject);
        return __assign(__assign(__assign({}, originalUrlHeader), customHeaders), authHeader);
    };
    HttpClient.prototype.handleRequestError = function(error, requestOptions) {
        var requestError = createHttpError(error);
        silent(function() {
            var _a;
            return (_a = requestOptions.onError) === null || _a === void 0 ? void 0 : _a.call(requestOptions, requestError);
        });
        throw requestError;
    };
    HttpClient.prototype.maybeFallbackRequest = function(err, requestOptions, urlObject, signedInstance) {
        var _a, _b, _c;
        var shouldFallbackRequest = isHttpMockServerEnabled() &&
            shouldAllowUnmocked() &&
            ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 404 &&
            ((_c = (_b = err.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.msg) === NO_SCENARIO_FOUND;
        if (shouldFallbackRequest) {
            var headers = this.getHeaders(requestOptions, signedInstance, urlObject);
            var prodOptions = buildOptions({
                requestOptions: requestOptions,
                urlObject: urlObject,
                headers: headers,
            });
            return this.client.request(prodOptions);
        }
        throw err;
    };
    HttpClient.prototype.transformResponse = function(res, requestOptions) {
        var requestId = requestIdOrEmptyString(res);
        var data = transformData(res, requestOptions);
        return __assign(__assign({}, res), {
            data: data,
            requestId: requestId
        });
    };
    /** @deprecated Please use the instance method instead, eg, httpClient.CancelToken.source() */
    HttpClient.CancelToken = axios.CancelToken;
    /** @deprecated Please use the instance method instead, eg, httpClient.isCancel() */
    HttpClient.isCancel = axios.isCancel;
    return HttpClient;
}());
export {
    HttpClient
};

function defaultClientOptions(opts) {
    var adapter = opts.adapter;
    if (!adapter) {
        // Default - related to 2 cases: Bundled to Client  / Bundled to Viewer (SSR - isolated VM)
        adapter = xhrAdapter;
        // 2 cases: Bundled to server (SSR) & classic Node (Not bundled at all) (axios needs to be in the node_modules)
        if (isNode()) {
            adapter = getNodeAdapter();
        }
    }
    return __assign({
        adapter: adapter,
        isSSR: false
    }, opts);
}

function getNodeAdapter() {
    // we use statically analyzable require calls to support bundlers: https://jira.wixpress.com/browse/APINF-172
    // https://github.com/webpack/webpack/issues/5939#issue-272316127
    if (typeof __webpack_require__ === 'function') {
        return __non_webpack_require__('axios/lib/adapters/http');
    }
    return require('axios/lib/adapters/http');
}

function transformData(res, requestOptions) {
    var resData = res.data;
    if (requestOptions._pickResponseBody) {
        resData = extractProp(res.data, requestOptions._pickResponseBody);
    }
    if (requestOptions._logs) {
        var logs = extractProp(res.data, requestOptions._logs);
        if (logs === null || logs === void 0 ? void 0 : logs.length) {
            logs.map(function(log) {
                return console.log.apply(console, log);
            });
        }
    }
    return resData;
}
export function createHttpClient() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return new(HttpClient.bind.apply(HttpClient, __spreadArray([void 0], args, false)))();
}
//# sourceMappingURL=http-client.js.map