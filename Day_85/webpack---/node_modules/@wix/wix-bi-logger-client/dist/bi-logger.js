'use strict';

var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
};

var _createClass = function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();

function _objectWithoutProperties(obj, keys) {
    var target = {};
    for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
    }
    return target;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var assert = require('./assert');

var _require = require('./utils/collections'),
    mapValues = _require.mapValues,
    filterValues = _require.filterValues;

var promise = require('./utils/promise');
var log = require('./utils/log');
var BatchQueue = require('./utils/batch-queue');

var _require2 = require('./consent-policy'),
    shouldMuteByCategory = _require2.shouldMuteByCategory,
    shouldMuteNonEssentials = _require2.shouldMuteNonEssentials,
    getPolicy = _require2.getPolicy;

var BiLogger = function() {
    //TODO: validate args
    function BiLogger(options, context) {
        _classCallCheck(this, BiLogger);

        this._publishers = options.publishers;
        this._validators = options.validators || [];
        this._defaults = options.defaults;
        this._ownDefaults = {};
        this._events = options.events || {};
        this._context = context || {};
        this._defaultValueTimeout = options.defaultValueTimeout || 5000;
        this._defaultContinueOnFail = options.defaultContinueOnFail || false;
        this._onPublisherFailHandler = options.onPublisherFailHandler || BiLogger._defaultPublisherFailHandler;
        this._isMuted = options.isMuted || function() {
            return false;
        };
        this._eventTransformer = options.eventTransformer || function(event) {
            return event;
        };
        this._payloadTransformer = options.payloadTransformer || function(payload) {
            return payload;
        };
        this._consentPolicyGetter = options.consentPolicyGetter || function() {
            return null;
        };
        this._nonEssentialDefaults = options.nonEssentialDefaults || {};
        this._maxBatchSize = options.maxBatchSize || 100;
        this._globalBatchQueue = options.globalBatchQueue;
    }

    _createClass(BiLogger, [{
        key: 'report',
        value: function report(data) {
            assert.defined(data, 'Data must be provided');
            assert.object(data, 'Data must be an object');

            var src = data.src,
                evid = data.evid,
                params = data.params,
                context = _objectWithoutProperties(data, ['src', 'evid', 'params']);

            return this.log(_extends({
                src: src,
                evid: evid
            }, params), context);
        }
    }, {
        key: 'log',
        value: function log(eventOrKey, eventOrContextOrUndefined, contextOrUndefined) {
            var _this = this;

            assert.defined(eventOrKey, 'Event object or event key must be provided.');

            var _extractEventAndConte = this._extractEventAndContext(eventOrKey, eventOrContextOrUndefined, contextOrUndefined),
                event = _extractEventAndConte.event,
                context = _extractEventAndConte.context;

            var policy = getPolicy(this._consentPolicyGetter);
            var fullContext = _extends({}, this._context, context);

            if (this._isMuted() || shouldMuteByCategory(policy, fullContext.category)) {
                return Promise.resolve();
            }

            if (fullContext.useBatch) {
                var queue = this._initQueue(fullContext, policy);

                var transformAndQueue = function transformAndQueue(_event) {
                    var transformedEvent = _this._eventTransformer(_event, fullContext);

                    return queue.feed(transformedEvent, fullContext);
                };

                if (this._globalBatchQueue) {
                    return this._getDefaults(this._defaults).then(function(defaults) {
                        var fullEvent = _extends({}, defaults, _this._getDynamicNonEssentialDefaults(policy), _this._getStaticNonEssentialDefaults(policy), event, _this._getPolicyFields(policy, fullContext.category));

                        return transformAndQueue(fullEvent);
                    });
                } else {
                    var fullEvent = _extends({}, this._getDynamicDefaults(this._defaults), this._getDynamicNonEssentialDefaults(policy), event, this._getPolicyFields(policy, fullContext.category));

                    return transformAndQueue(fullEvent);
                }
            }

            return this._getDefaults(this._defaults).then(function(defaults) {
                var fullEvent = Object.assign(defaults, _this._getDynamicNonEssentialDefaults(policy), _this._getStaticNonEssentialDefaults(policy), event, _this._getPolicyFields(policy, fullContext.category));

                var validatorsResult = _this._validators.length === 0 ? true : _this._validators.some(function(validator) {
                    return validator.match(fullEvent) && (validator.execute(fullEvent) || true);
                });

                if (!validatorsResult) {
                    throw new Error('No validator accepted the event. Source: ' + fullEvent.src + ' Evid: ' + (fullEvent.evid || fullEvent.evtId));
                }

                var transformedEvent = _this._eventTransformer(fullEvent, fullContext);
                transformedEvent = _this._payloadTransformer(transformedEvent, fullContext);

                return _this._send(transformedEvent, fullContext);
            });
        }
    }, {
        key: 'flush',
        value: function flush() {
            if (!this._queue) {
                return Promise.resolve();
            }
            return this._queue.flush();
        }
    }, {
        key: 'updateDefaults',
        value: function updateDefaults(defaults) {
            assert.defined(defaults, 'Defaults must be provided');
            assert.object(defaults, 'Defaults must be an object');
            Object.assign(this._ownDefaults, defaults);
            return this;
        }
    }, {
        key: '_send',
        value: function _send(payload) {
            var _this2 = this;

            var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            return Promise.all(this._publishers.map(function(publisher) {
                var cloned = _extends({}, payload);

                return Promise.resolve().then(function() {
                    return publisher(cloned, context);
                }).catch(function(error) {
                    return _this2._onPublisherFailHandler(error, {
                        publisherName: publisher.name,
                        payload: payload
                    });
                });
            })).then(function() {
                return undefined;
            });
        }
    }, {
        key: '_extractEventAndContext',
        value: function _extractEventAndContext(eventOrKey, eventOrContextOrUndefined, contextOrUndefined) {
            var event = void 0;
            var context = {};

            if (typeof eventOrKey !== 'string') {
                event = eventOrKey;
                context = eventOrContextOrUndefined || context;
            } else {
                event = this._events[eventOrKey];

                if (!event) {
                    throw new assert.AssertionError('Event with key \'' + eventOrKey + '\' not found in event map.');
                }

                if (eventOrContextOrUndefined) {
                    event = _extends({}, event, eventOrContextOrUndefined);
                    context = contextOrUndefined || context;
                }
            }

            return {
                event: event,
                context: context
            };
        }
    }, {
        key: '_initQueue',
        value: function _initQueue(context, policy) {
            var _this3 = this;

            if (this._queue) {
                return this._queue;
            }

            this._queue = this._globalBatchQueue || new BatchQueue();

            var onFlush = function onFlush(batch) {
                // if queue is global don't define global properties
                if (!_this3._globalBatchQueue) {
                    batch.g = Object.assign(_this3._getStaticDefaults(_this3._defaults), _this3._getStaticNonEssentialDefaults(policy));
                }

                var transformedPayload = _this3._payloadTransformer(batch, context);

                return _this3._send(transformedPayload, context);
            };

            this._queue.init({
                delayMs: context.useBatch === true ? 300 : context.useBatch,
                maxBatchSize: this._maxBatchSize,
                useThrottle: !!this._globalBatchQueue,
                optimizeBatch: !!this._globalBatchQueue
            }, onFlush);

            return this._queue;
        }
    }, {
        key: '_handleDefaultsError',
        value: function _handleDefaultsError(err) {
            if (this._defaultContinueOnFail) {
                log.error(err);
                return null;
            }
            return Promise.reject(err);
        }
    }, {
        key: '_getDynamicNonEssentialDefaults',
        value: function _getDynamicNonEssentialDefaults(policy) {
            if (!shouldMuteNonEssentials(policy)) {
                return this._getDynamicDefaults(this._nonEssentialDefaults);
            }
        }
    }, {
        key: '_getStaticNonEssentialDefaults',
        value: function _getStaticNonEssentialDefaults(policy) {
            if (!shouldMuteNonEssentials(policy)) {
                return this._getStaticDefaults(this._nonEssentialDefaults);
            }
        }
    }, {
        key: '_withOwnDefaults',
        value: function _withOwnDefaults(defaults) {
            return Object.assign({}, defaults, this._ownDefaults);
        }
    }, {
        key: '_getDynamicDefaults',
        value: function _getDynamicDefaults(defaults) {
            defaults = this._withOwnDefaults(defaults);
            var dynamicDefaults = filterValues(defaults, function(v) {
                return typeof v === 'function';
            });
            return mapValues(dynamicDefaults, function(v) {
                return v();
            });
        }
    }, {
        key: '_getStaticDefaults',
        value: function _getStaticDefaults(defaults) {
            defaults = this._withOwnDefaults(defaults);
            var staticDefaults = filterValues(defaults, function(v) {
                return typeof v !== 'function';
            });
            return staticDefaults;
        }
    }, {
        key: '_getDefaults',
        value: function _getDefaults(defaults) {
            var _this4 = this;

            defaults = this._withOwnDefaults(defaults);
            if (!defaults) {
                return Promise.resolve({});
            }

            var promises = mapValues(defaults, function(value, key) {
                if (typeof value === 'function') {
                    try {
                        value = value();
                    } catch (err) {
                        return _this4._handleDefaultsError(err);
                    }
                }

                if (value && typeof value.then === 'function') {
                    return promise.timedPromise(value, {
                        message: 'Cannot get default value \'' + key + ' for BI Event\'',
                        timeout: _this4._defaultValueTimeout
                    }).catch(function(err) {
                        return _this4._handleDefaultsError(err);
                    });
                }

                return value;
            });

            return promise.allAsObject(promises);
        }
    }, {
        key: '_encodePolicyValue',
        value: function _encodePolicyValue(policy, key) {
            if (!policy) {
                return 1;
            }

            if (typeof policy[key] === 'boolean') {
                return policy[key] ? 1 : 0;
            }

            return policy[key];
        }
    }, {
        key: '_getPolicyFields',
        value: function _getPolicyFields(policy, category) {
            return {
                _isca: this._encodePolicyValue(policy, 'analytics'),
                _iscf: this._encodePolicyValue(policy, 'functional'),
                _ispd: policy.__default ? 1 : 0,
                _ise: category === 'essential' ? 1 : 0
            };
        }
    }], [{
        key: '_defaultPublisherFailHandler',
        value: function _defaultPublisherFailHandler(error, _ref) {
            var publisherName = _ref.publisherName;

            return publisherName; // do nothing
        }
    }]);

    return BiLogger;
}();

module.exports = BiLogger;
//# sourceMappingURL=bi-logger.js.map