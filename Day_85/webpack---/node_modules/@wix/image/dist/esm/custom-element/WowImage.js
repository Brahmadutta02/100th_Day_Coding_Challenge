import {
    getImageSrc
} from './utils';
import ImageLoader from './ImageLoader';
import imageLayout from './imageLayout';
const TIMEOUT = 250;

function wowImageFactory(services, environmentConsts) {
    if (!services.imageLoader) {
        services.imageLoader = new ImageLoader(services.mutationService);
    }
    return class WowImage extends HTMLElement {
        constructor() {
            // eslint-disable-line no-useless-constructor
            super();
            this.childListObserver = null;
            this.timeoutId = null;
        }
        attributeChangedCallback(_, oldValue) {
            if (oldValue) {
                this.reLayout();
            }
        }
        connectedCallback() {
            this.observeResize();
            this.reLayout();
        }
        disconnectedCallback() {
            this.unobserveResize();
            services.imageLoader.onImageDisconnected(this);
            this.unobserveChildren();
        }
        static get observedAttributes() {
            return ['data-image-info'];
        }
        reLayout() {
            const domNodes = {};
            const measures = {};
            const imageId = this.getAttribute('id');
            const imageInfo = JSON.parse(this.dataset.imageInfo || '');
            // const isResponsive = this.dataset.isResponsive === 'true';
            const {
                bgEffectName
            } = this.dataset;
            domNodes[imageId] = this;
            if (imageInfo.containerId) {
                domNodes[imageInfo.containerId] = document.getElementById(`${imageInfo.containerId}`);
            }
            domNodes.image = this.querySelector('img');
            // domNodes.picture = this.querySelector('picture');
            const containerElm = imageInfo.containerId ?
                domNodes[imageInfo.containerId] :
                undefined;
            if (!domNodes.image) {
                // missing children, can't layout, wait for children to be created first
                const target = this;
                this.observeChildren(target);
                return;
            }
            // clean up
            this.unobserveChildren();
            // from now on just observe changes to children of top level
            this.observeChildren(this);
            services.mutationService.measure(() => {
                // if (isResponsive) {
                //   imageLayoutResponsive.measure(
                //     imageId,
                //     measures as WixImageXMeasures,
                //     domNodes,
                //   );
                // } else {
                imageLayout.measure(imageId, measures, domNodes, {
                    containerElm,
                    bgEffectName,
                }, services);
            });
            const patchImage = (shouldLoadImage) => {
                services.mutationService.mutate(() => {
                    // if (isResponsive) {
                    //   imageLayoutResponsive.patch(
                    //     imageId,
                    //     measures as WixImageXMeasures,
                    //     domNodes,
                    //     imageInfo,
                    //     services,
                    //     environmentConsts,
                    //     shouldLoadImage,
                    //   );
                    // } else {
                    imageLayout.patch(imageId, measures, domNodes, imageInfo, services, environmentConsts, shouldLoadImage, bgEffectName);
                });
            };
            // if image has no src or current src if from ssr render stage  -
            // load the image immediately, otherwise - debounce the reload
            if (!getImageSrc(domNodes.image) ||
                this.dataset.hasSsrSrc) {
                patchImage(true);
            } else {
                this.debounceImageLoad(patchImage);
            }
        }
        /**
         * Debounce consecutive image loads
         *
         * @param {function} patchImage closure for patching the image
         */
        debounceImageLoad(patchImage) {
            clearTimeout(this.timeoutId);
            this.timeoutId = setTimeout(() => {
                patchImage(true);
            }, TIMEOUT);
            patchImage(false);
        }
        observeResize() {
            var _a;
            (_a = services.resizeService) === null || _a === void 0 ? void 0 : _a.observe(this);
        }
        unobserveResize() {
            var _a;
            (_a = services.resizeService) === null || _a === void 0 ? void 0 : _a.unobserve(this);
        }
        /**
         * Observe DOM mutations to wait for addition of missing children
         *
         * @param {HTMLElement} parent
         */
        observeChildren(parent) {
            if (!this.childListObserver) {
                this.childListObserver = new window.MutationObserver(() => this.reLayout());
            }
            this.childListObserver.observe(parent, {
                childList: true
            });
        }
        /**
         * Remove DOM MutationObserver if one was created
         */
        unobserveChildren() {
            if (this.childListObserver) {
                this.childListObserver.disconnect();
                this.childListObserver = null;
            }
        }
    };
}
export default wowImageFactory;
//# sourceMappingURL=WowImage.js.map