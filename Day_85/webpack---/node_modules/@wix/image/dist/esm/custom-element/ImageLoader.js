import {
    getImageSrc
} from './utils';
// const SCROLL_EFFECT_CSS_CLASS = 'scroll-css-var--scrollEffect';
// exclusion of Edge18: https://jira.wixpress.com/browse/BOLT-1828
const isEdge18 = () => /Edge\/18/.test(window.navigator.userAgent);
const isIntersectionObserverSupported = () => window &&
    'IntersectionObserver' in window &&
    'IntersectionObserverEntry' in window &&
    'intersectionRatio' in window.IntersectionObserverEntry.prototype &&
    'isIntersecting' in window.IntersectionObserverEntry.prototype &&
    !isEdge18(); // due to bug in intersectionObserver Edge18 for strips with parallax|reveal effect, images in fixed position
class ImageLoader {
    constructor(mutationService) {
        this.mutationService = mutationService;
        if (isIntersectionObserverSupported()) {
            this.intersectionObserver = new IntersectionObserver(this.getViewPortIntersectionHandler(), {
                rootMargin: '50% 0px'
            });
            // this.scrollEffectsIntersectionObserver = new IntersectionObserver(
            //   this.getScrollEffectsIntersectionHandler(),
            //   { rootMargin: '10% 0px' },
            // );
        }
    }
    isImageInViewPort(boundingRect, screenHeight) {
        return (boundingRect.top + boundingRect.height >= 0 &&
            boundingRect.bottom - boundingRect.height <= screenHeight);
    }
    loadImage(wixImageNode, {
        // withScrollEffectVars,
        screenHeight,
        boundingRect,
    }) {
        // TODO: do not check manually is-in-viewport, breaks lazy-load of fixed positioned images
        // but find solution for hover-box blink
        if (!this.intersectionObserver ||
            this.isImageInViewPort(boundingRect, screenHeight)) {
            this.setImageSource(wixImageNode);
        } else {
            this.intersectionObserver.unobserve(wixImageNode);
            this.intersectionObserver.observe(wixImageNode);
        }
        // if (withScrollEffectVars && this.scrollEffectsIntersectionObserver) {
        //   this.scrollEffectsIntersectionObserver.unobserve(wixImageNode);
        //   this.scrollEffectsIntersectionObserver.observe(wixImageNode);
        // }
    }
    onImageDisconnected(wixImageNode) {
        if (this.intersectionObserver) {
            this.intersectionObserver.unobserve(wixImageNode);
        }
        // if (this.scrollEffectsIntersectionObserver) {
        //   this.scrollEffectsIntersectionObserver.unobserve(wixImageNode);
        // }
    }
    setSrcAttribute(imageNode, src) {
        const currentSrc = getImageSrc(imageNode);
        if (currentSrc === src) {
            return;
        }
        // We always want to fetch images within viewport with high priority
        imageNode.setAttribute('fetchpriority', 'high');
        imageNode.src = src;
    }
    // setSourceSetAttribute(sourceNode: HTMLSourceElement, src: string) {
    //   const currentSrc = sourceNode.srcset;
    //
    //   if (currentSrc === src) {
    //     return;
    //   }
    //
    //   sourceNode.srcset = src;
    // }
    setImageSource(wixImageNode) {
        const imageNode = wixImageNode.querySelector('img');
        // const pictureNode = wixImageNode.querySelector('picture');
        this.setSrcAttribute(imageNode, wixImageNode.dataset.src);
        // if (pictureNode) {
        //   Array.from(pictureNode.querySelectorAll('source')).forEach(
        //     (sourceNode: HTMLSourceElement) => {
        //       this.setSourceSetAttribute(sourceNode, sourceNode.dataset.srcset!);
        //     },
        //   );
        // }
    }
    getViewPortIntersectionHandler() {
        return (entries, observer) => {
            entries
                .filter((entry) => entry.isIntersecting)
                .forEach((entry) => {
                    const lazyImage = entry.target;
                    this.setImageSource(lazyImage);
                    observer.unobserve(lazyImage);
                });
        };
    }
}
export default ImageLoader;
//# sourceMappingURL=ImageLoader.js.map