"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.evaluateBundle = exports.getModel = exports.getModelFromContext = exports.getGlobalModel = exports.getEnvironment = exports.requireAMDModule = exports.getGlobal = exports.isOriginalRequireFunctionAvailable = exports.getOriginalRequireFunction = void 0;
/* eslint-disable no-new-func */
/* eslint-disable no-eval */
const editor_elements_conventions_1 = require("@wix/editor-elements-conventions");
const utils_1 = require("../utils");
const workaround = {};
/**
 * trick to leave `require` as is after webpack build
 * it makes possible to run the same bundle on server and client
 */
eval(`workaround.getRequireFunction = () => typeof require !== 'undefined' ? require : undefined`);

function getOriginalRequireFunction() {
    return workaround.getRequireFunction();
}
exports.getOriginalRequireFunction = getOriginalRequireFunction;

function isOriginalRequireFunctionAvailable() {
    return typeof getOriginalRequireFunction() !== 'undefined';
}
exports.isOriginalRequireFunctionAvailable = isOriginalRequireFunctionAvailable;

function getGlobal() {
    return (typeof globalThis !== 'undefined' ?
        globalThis :
        typeof window !== 'undefined' ?
        window :
        typeof self !== 'undefined' ?
        self :
        typeof global !== 'undefined' ?
        global :
        null);
}
exports.getGlobal = getGlobal;

function requireAMDModule(id) {
    /**
     * This is workaround for webpack...
     * if just use `require` function directly, webpack will transpile it to
     * `__webpack_require__(n)` that always leads to module that throws exception like `module if not defined`
     */
    const localRequire = getOriginalRequireFunction();
    return new Promise(resolve => {
        /**
         * Trigger `require` to fix `require.specified`
         * https://github.com/requirejs/requirejs/issues/1305#issuecomment-87924865
         **/
        localRequire([]);
        /**
         * To prevent fetching module with `requirejs`
         */
        if (localRequire.specified(id)) {
            localRequire([id], (model) => {
                resolve(model);
            });
        } else {
            resolve(undefined);
        }
    });
}
exports.requireAMDModule = requireAMDModule;
const parseDefineArguments = (...args) => {
    if (args.length === 3) {
        return {
            id: args[0],
            deps: args[1],
            factory: args[2],
        };
    } else if (args.length === 2) {
        return {
            id: typeof args[0] === 'string' ? args[0] : null,
            deps: Array.isArray(args[0]) ? args[0] : [],
            factory: args[1],
        };
    } else {
        return null;
    }
};

function wrapDefineFunction(params) {
    /**
     * If components library was bundled with "umdNamedDefine: true", the UMD header in bundle will be:
     * ...
     * define('bundleId', [], factory)
     * ...
     *
     * If components "umdNamedDefine: false":
     * ...
     * define([], factory)
     * ...
     *
     * So this is anonymous define call, that means that it is not possible to require it after the evaluation
     * Better to track these cases.
     */
    let defineForBundle;
    if (params.define) {
        defineForBundle = (...args) => {
            const parsed = parseDefineArguments(...args);
            if (!parsed) {
                throw new Error('x');
            }
            const {
                id,
                deps,
                factory
            } = parsed;
            const globals = params.globals;
            const filteredDeps = deps.filter(key => !globals || (globals && !globals[key]));
            if (globals) {
                params.define(id, filteredDeps, (...values) => {
                    const allValues = deps.map(dep => {
                        const index = filteredDeps.findIndex(_dep => _dep === dep);
                        if (index === -1) {
                            return globals[dep];
                        } else {
                            return values[index];
                        }
                    });
                    return factory(...allValues);
                });
            } else {
                params.define(...args);
            }
        };
        defineForBundle.amd = params.define.amd;
    }
    return defineForBundle;
}

function getDefineFunction() {
    const currentGlobal = getGlobal();
    return typeof currentGlobal.define === 'function' && currentGlobal.define.amd ?
        currentGlobal.define :
        null;
}

function getEnvironment({
    id,
    globals,
}) {
    const currentGlobal = getGlobal();
    const _define = getDefineFunction();
    let self = currentGlobal;
    if (globals && !_define) {
        self = new Proxy(currentGlobal, {
            get(target, key) {
                const store = key in globals ? globals : target;
                const value = store[key];
                if (typeof value === 'function') {
                    const returnValue = (...args) => value.apply(store, args);
                    Object.assign(returnValue, value);
                    return returnValue;
                } else {
                    return value;
                }
            },
        });
    }
    const currentRequire = getOriginalRequireFunction();
    return {
        /**
         * for requirejs environment
         */
        define: wrapDefineFunction({
            id,
            define: _define,
            globals
        }),
        /**
         * `workaround.require` – always default require function
         * for SSR – it is node require
         * for CSR – it is requirejs
         */
        require: currentRequire ?
            name => {
                if (globals && globals[name]) {
                    return globals[name];
                }
                return currentRequire(name);
            } :
            undefined,
        /**
         * always force `module` to be undefine during bundle evaluation
         */
        module: undefined,
        /**
         * commonjs & commonjs2
         *
         * for server env. we provide `exports` as plain object
         * after evaluation, it is possible to get the results:
         * env.exports[bundleId]
         */
        exports: (0, utils_1.isServer)() && isOriginalRequireFunctionAvailable() ? {} : undefined,
        /**
         *
         */
        self,
    };
}
exports.getEnvironment = getEnvironment;

function getGlobalModel(id) {
    const env = getEnvironment({
        id
    });
    const model = env.self[id];
    if (!model && typeof env.define === 'function') {
        return requireAMDModule(id);
    }
    return model;
}
exports.getGlobalModel = getGlobalModel;

function getModelFromContext(id, context) {
    if (!context) {
        return null;
    }
    const lazyFactoryID = (0, editor_elements_conventions_1.getLazyFactoryID)(id);
    const factory = context[lazyFactoryID];
    if (factory && !factory.invoked) {
        factory.invoked = true;
        factory();
    }
    return context[id];
}
exports.getModelFromContext = getModelFromContext;
async function getModel(id) {
    const factory = await getGlobalModel((0, editor_elements_conventions_1.getLazyFactoryID)(id));
    if (factory && !factory.invoked) {
        factory.invoked = true;
        factory();
    }
    /**
     * Probably we need to check pending script tags
     */
    return getGlobalModel(id);
}
exports.getModel = getModel;

function evaluateBundle(bundle, {
    id,
    globals,
    contexts,
    useExperimentalEval,
} = {}) {
    const env = getEnvironment({
        id,
        globals
    });
    if (useExperimentalEval) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        (function({
            define,
            require,
            module,
            exports,
            self
        }) {
            eval(`${bundle}
//# sourceURL=webpack-internal://`);
        })(env);
    } else {
        const evaluateBundleSources = new Function('define', 'require', 'module', 'exports', 'self', bundle);
        evaluateBundleSources(env.define, env.require, env.module, env.exports, env.self);
    }
    if (!id) {
        return;
    }
    if (typeof env.exports === 'object') {
        contexts[id] = env.exports;
    }
}
exports.evaluateBundle = evaluateBundle;
//# sourceMappingURL=evaluateBundle.js.map